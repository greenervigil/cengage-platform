'use strict'

const chai   = require('chai')
const expect = chai.expect
const http   = require('http')
const sinon  = require('sinon')
const Plugin = require('../index')

describe('Children', () => {

  it('should return an object when there are ignored paths', () => {
    const plugin = new Plugin({})

    const children = plugin.children({ ignored: [ '/ignore' ] })
    const expected = { '/ignore': { enabled: false } }

    expect(children).to.eql(expected)
  })

  it('should return an empty object when there aren\'t ignored paths', () => {
    const plugin = new Plugin({})

    const children = plugin.children({})
    const expected = {}

    expect(children).to.eql(expected)
  })
})



describe('trends', () => {

  it('should resolve trends data', () => {
    const plugin = new Plugin({})
    const req = {
      fetchHandlerTime: sinon.spy()
    }
    const res = {}
    const config = {}

    let resolver = null
    const p1 = new Promise((resolve) => {
      resolver = resolve
    })

    p1.then((data) => {
      expect(data).to.not.be.undefined
    })

    plugin.trends(config)(req, res, resolver)      
  })
})

describe('Should Run', () => {
  it('should return true when the plugin is enabled', () => {
    const plugin = new Plugin({})
    const config = { enabled: true }

    expect(plugin.shouldRun(null, null, null, config)).to.be.true
  })

  it('should return false when the plugin is not enabled', () => {
    const plugin = new Plugin({})
    const config = { enabled: false }

    expect(plugin.shouldRun(null, null, null, config)).to.be.false
  })
})

describe('Middleware', () => {
  it('should run the middleware', () => {
    const plugin = new Plugin({})
    const req = {
      session: { headers: [] },
      preserveSession: sinon.spy()
    }
    const res = sinon.spy()
    const next = sinon.spy()

    plugin.middleware()(req, res, next, { enabled: true })

    expect(next.calledOnce).to.be.true
  })

  it('should set the cengage_trace_phrase', () => {
    const plugin = new Plugin({})
    const req = {
      session: { headers: [] },
      preserveSession: sinon.spy()
    }
    const res = sinon.spy()
    const next = sinon.spy()

    plugin.middleware()(req, res, next, { enabled: true })

    expect(req.session.headers).to.have.property('cengage_trace_phrase')
    expect(next.calledOnce).to.be.true
  })

  it('should not return a header when not enabled', () => {
    const plugin = new Plugin({})
    const req = {
      session: { headers: [] },
      preserveSession: sinon.spy()
    }
    const res = sinon.spy()
    const next = sinon.spy()

    plugin.middleware()(req, res, next, { enabled: false })

    expect(req.session.headers).to.not.have.property('cengage_trace_phrase')
    expect(next.callCount).to.eql(1)
  })

  it('should return the same header when called twice and configured with sessionAware config', () => {
    const plugin = new Plugin({})
    const req1 = {
      headers: [ { 'cmp-session-id': 'test-session' } ],
      session: { headers: [] },
      preserveSession: sinon.spy()
    }
    const res = null
    const next = sinon.spy()

    plugin.middleware()(req1, res, next, { enabled: true, sessionAware: true })

    const req1phrase = req1.session.headers.cengage_trace_phrase

    const req2 = {
      session: {
        headers: [],
        'cengage_trace_phrase': {
          'phrase' : req1phrase
        }
      },
      preserveSession: sinon.spy()
    }
    plugin.middleware()(req2, res, next, { enabled: true, sessionAware: true })

    expect(req1phrase).to.eql(req2.session.headers.cengage_trace_phrase)
    expect(req1.preserveSession.calledOnce).to.be.true
    expect(req2.preserveSession.calledOnce).to.be.true
  })

  it('should return a different header when called twice and configured without sessionAware config', () => {
    const plugin = new Plugin({})
    const req1 = {
      headers: [ { 'cmp-session-id': 'test-session' } ],
      session: { headers: [] },
      preserveSession: sinon.spy()
    }
    const res = null
    const next = sinon.spy()

    plugin.middleware()(req1, res, next, { enabled: true, sessionAware: true })

    const req1phrase = req1.session.headers.cengage_trace_phrase

    const req2 = {
      session: {
        headers: [],
        'cengage_trace_phrase': {
          'phrase' : req1phrase
        }
      },
      preserveSession: sinon.spy()
    }
    plugin.middleware()(req2, res, next, { enabled: true })

    expect(req1phrase).to.not.eql(req2.session.headers.cengage_trace_phrase)
    expect(req1.preserveSession.calledOnce).to.be.true
    expect(req2.preserveSession.calledOnce).to.be.false
  })

  it('should return a header phrase containing 3 words', () => {
    const plugin = new Plugin({})
    const req = {
      session: { headers: [] },
      preserveSession: sinon.spy()
    }
    const res = null
    const next = sinon.spy()

    plugin.middleware()(req, res, next, { enabled: true })

    expect(req.session.headers.cengage_trace_phrase.split(' ').length).to.eql(3)
  })

  it('should respect the headerName config', () => {
    const plugin = new Plugin({})
    const headerName = 'my_test_header'
    const req = {
      session: { headers: [] },
      preserveSession: sinon.spy()
    }
    const res = null
    const next = sinon.spy()

    plugin.middleware()(req, res, next, { enabled: true, headerName: headerName })

    expect(req.session.headers).to.have.property(headerName)
  })

  it('should not have the default headerName when the headerName config is set', () => {
    const plugin = new Plugin({})
    const headerName = 'my_test_header'
    const req = {
      session: { headers: [] },
      preserveSession: sinon.spy()
    }
    const res = null
    const next = sinon.spy()

    plugin.middleware()(req, res, next, { enabled: true, headerName: headerName })

    expect(req.session.headers).to.not.have.property('cengage_trace_phrase')
  })

  it('should share phrases between header names when "sessionAware" and "sharedPhrase" is set', () => {
    const plugin = new Plugin({})
    const req1 = {
      headers: [ { 'cmp-session-id': 'test-session' } ],
      session: { headers: [] },
      preserveSession: sinon.spy()
    }
    const res = null
    const next = sinon.spy()

    plugin.middleware()(req1, res, next, { enabled: true, sessionAware: true })

    const req1phrase = req1.session.headers.cengage_trace_phrase

    const req2 = {
      session: {
        headers: [],
        'cengage_trace_phrase': {
          'phrase' : req1phrase
        }
      },
      preserveSession: sinon.spy()
    }
    const headerName = 'my_test_header'
    plugin.middleware()(req2, res, next, { enabled: true, sessionAware: true, headerName: headerName, sharedPhrase: true })

    expect(req1phrase).to.eql(req2.session.headers[headerName])
  })

  it('should not share phrases between header names when only "sharedPhrase" is set (but "sessionAware" is not)', () => {
    const plugin = new Plugin({})
    const req1 = {
      headers: [ { 'cmp-session-id': 'test-session' } ],
      session: { headers: [] },
      preserveSession: sinon.spy()
    }
    const res = null
    const next = sinon.spy()

    plugin.middleware()(req1, res, next, { enabled: true, sessionAware: true })

    const req1phrase = req1.session.headers.cengage_trace_phrase

    const req2 = {
      session: {
        headers: [],
        'cengage_trace_phrase': {
          'phrase' : req1phrase
        }
      },
      preserveSession: sinon.spy()
    }
    const headerName = 'my_test_header'
    plugin.middleware()(req2, res, next, { enabled: true, headerName: headerName, sharedPhrase: true })

    expect(req1phrase).to.not.eql(req2.session.headers[headerName])
  })
})

