const _ = require('lodash')
const getRawBody = require('raw-body')
const typer = require('media-typer')
const querystring = require('querystring')
const URL = require('url')
const semver = require('semver')

/*
 * Authentication Interface for session plugins
 */
module.exports = function (pkg, schema) {
  const BasePlugin = require('cmp-plugin-base')(pkg, schema)

  return class AuthenticationPlugin extends BasePlugin {

    init() {
      this.headerPrefix = _.get(this.rootConfig, 'headerPrefix', 'cengage-sso')

      this.authHandlers = {
        'allow': this.handleAuthModeAllow,
        'restrict': this.handleAuthModeRestrict
      }

      this.authModes = Object.keys(this.authHandlers)
      this.notPropagated = this.authModes.concat([ 'post' ])

      this.defaults = {
        transformers: Object.freeze({
          'role': 'lower'
        }),
        mappings: {
          requestParams: Object.freeze([]),
          authResponse: Object.freeze({})
        }
      }

      this.util = {
        transformFunctions: {
          lower: String.prototype.toLowerCase,
          upper: String.prototype.toUpperCase,
          string: String,
          bool: Boolean
        }
      }
    }

    static get level() {
      return 1000
    }

    children(config) {
      const childs = {}

      _.get(config, 'post.paths', []).reduce((accumulator, path) => {
        accumulator[path] = Object.assign({}, accumulator[path], { post: true })
      }, childs)

      this.authModes.reduce((accumulator, mode) => {
        const paths = _(config).get(`${mode}.paths`, []).valueOf()
        paths.forEach(path => {
          accumulator[path] = Object.assign({}, accumulator[path], { mode })
        })
        return accumulator
      }, childs)

      return childs
    }

    registerMode(mode, handler) {
      this.authHandlers[mode] = handler
      this.authModes = Object.keys(this.authHandlers)
      this.notPropagated = this.authModes.concat([ 'post' ])
    }

    shouldRun(req, res, next, config) {
      return true //config.enabled
    }

    /**
     * HEADER/SESSION MANIPULATION
     */

    clearHeaders(req = {}) {
      return _.set(req, 'session.headers', {})
    }

    getFallbackValue(req, key, options = {}) {
      if (options.namespace) {
        return _.get(req, `session.fallback['${options.namespace}']${key}`)
      } else {
        return _.get(req, `session.fallback.${key}`)
      }
    }

    setFallbackValue(req, key, value, options = {}) {
      const func = (value) ? _.set : _.unset
      if (options.namespace) {
        return func(req, `session.fallback['${options.namespace}'].${key}`, value)
      } else {
        return func(req, `session.fallback.${key}`, value)
      }
    }

    getHeaderValue(req, key) {
      return _.get(req, `session.headers.${this.headerPrefix}-${key}`)
    }

    setHeaderValue(req, key, value) {
      const func = (value) ? _.set : _.unset
      return func(req, `session.headers.${this.headerPrefix}-${key}`, value)
    }

    getSessionValue(req, key, options = {}) {
      if (options.namespace) {
        return _.get(req, `session.${this.name}['${options.namespace}'].${key}`)
      } else {
        return _.get(req, `session.${this.name}.${key}`)
      }
    }

    setSessionValue(req, key, value, options = {}) {
      const func = (value) ? _.set : _.unset
      if (options.namespace) {
        return func(req, `session.${this.name}['${options.namespace}'].${key}`, value)
      } else {
        return func(req, `session.${this.name}.${key}`, value)
      }
    }

    getParamHeaderValue(req, key) {
      return _.get(req, `session.headers.cmp-dynamic-${key}`)
    }

    setParamHeaderValue(req, key, value) {
      const func = (value) ? _.set : _.unset
      return func(req, `session.headers.cmp-dynamic-${key}`, value)
    }

    getParamSessionValue(req, key, options = {}) {
      if (options.namespace) {
        return _.get(req, `session.params['${options.namespace}']${key}`)
      } else {
        return _.get(req, `session.params.${key}`)
      }
    }

    setParamSessionValue(req, key, value, options = {}) {
      const func = (value) ? _.set : _.unset
      if (options.namespace) {
        return func(req, `session.params['${options.namespace}'].${key}`, value)
      } else {
        return func(req, `session.params.${key}`, value)
      }
    }

    /**
     * HANDLE MODES
     */
    handleAuthMode(req, res, next, config, options) {
      (this.authHandlers[(config.mode || '').toLowerCase()] || function () {
        const { token } = this.getParams(req)

        this.baseConfig.logger.warn({
          action: 'bad authentication mode handler',
          value: config.mode,
          host: req.header('host'),
          token: this.truncateToken(token),
          ssoGuid: this.getSessionValue(req, 'guid', options),
          sessionId: req.sessionId
        })
      }).call(this, req, res, next, config)
    }

    handleAuthModeAllow(req, res, next, config) {
      next()
    }

    handleAuthModeRestrict(req, res, next, config) {
      res.location(config.login).status(401).end()
    }

    notAuthenticated(req, res, next, config, options) {
      this.clearHeaders(req)
      this.handleAuthMode(req, res, next, config, options)
    }

    /**
     * HELPER FUNCTIONS
     */
    getExpiration(ttl = 3600) {
      return new Date().getTime() + ttl * 1000
    }

    getExpiringToken(req, config, options) {
      const prevToken = this.getSessionValue(req, 'token', options)
      const expiration = this.getSessionValue(req, 'expiration', options)

      return (this.isAuth(req) && this.shouldRefresh(expiration, config.ttl)) ? prevToken : ''
    }

    getRequestToken(req) {
      return this.getParams(req).token
    }

    // Get the parameters from the query string or body
    getParams(req = {}, options) {
      const reqRefreshHeader = _.get(req, `headers[${this.headerPrefix}-refresh]`)
      const proxyResRefreshHeader = _.get(req, `proxyResHeaders[${this.headerPrefix}-refresh]`)
      const noRefreshHeader = !(reqRefreshHeader || proxyResRefreshHeader)
      return _.defaultsDeep(
        {},
        req.body,
        req.params,
        _.get(req, 'result.dynamic', {}),
        noRefreshHeader ? {} : {
          token: _.get(req, 'session.sso.token', ''),
          eISBN: this.getParamSessionValue(req, 'eISBN', options),
          courseKey: this.getParamSessionValue(req, 'courseKey', options),
          courseCgi: this.getParamSessionValue(req, 'courseCgi', options)
        }
      )
    }

    getNamespace(params = {}) {
      if (_.isEmpty(params)) return ''
      return (params.courseCgi) ? `cgi:${params.courseCgi}` : `key:${params.courseKey}`
    }

    addStatic(collection = {}) {
      const collectionWithStatic = Object.assign(collection, {
        static: new Proxy({}, {
          get: (target, name) => {
            try {
              return decodeURI(name.toString())
            } catch (e) {
              this.baseConfig.logger.error({
                action: 'retrieve static mapping value',
                error: e
              })
            }
          }
        })
      })

      return collectionWithStatic
    }

    getValueFromMappings(collection, keys) {
      const keysReduced = _(keys).split('|').reduce((acc, key) => {
        return acc ? acc : _.get(this.addStatic(collection), key, '')
      }, '')
      return keysReduced
    }

    isAuth(req, options) {
      const token = this.getSessionValue(req, 'token', options)
      const expiration = this.getSessionValue(req, 'expiration', options)

      return token && (expiration > new Date().getTime())
    }

    hasFallbackPrivilege(req, options = {}) {
      if (options.namespace) {
        return _.get(req, `session.fallback['${options.namespace}'].privileged`, false)
      } else {
        return _.get(req, 'session.fallback.privileged', false)
      }
    }

    mapFallbackToHeaders(req, options = {}) {
      if (options.namespace) {
        Object.keys(_.get(req, `session.fallback['${options.namespace}']`, {})).forEach(key => {
          const val = _.get(req, `session.fallback['${options.namespace}'].${key}`)
          if (!_.isObject(val)) {
            this.setHeaderValue(req, key, val)
          }
        })

        Object.keys(_.get(req, `session.params['${options.namespace}']`, {})).forEach(key => {
          const val = _.get(req, `session.params['${options.namespace}'].${key}`)
          if (!_.isObject(val)) {
            this.setParamHeaderValue(req, key, val)
          }
        })
      } else {
        Object.keys(_.get(req, 'session.fallback', {})).forEach(key => {
          const val = _.get(req, `session.fallback.${key}`)
          if (!_.isObject(val)) {
            this.setHeaderValue(req, key, val)
          }
        })

        Object.keys(_.get(req, 'session.params', {})).forEach(key => {
          const val = _.get(req, `session.params.${key}`)
          if (!_.isObject(val)) {
            this.setParamHeaderValue(req, key, val)
          }
        })
      }
    }

    mapFallbacksToSession(req, data, config, options) {
      const fallbackMappings = _.get(config, 'mappings.fallback', {})
      const transformers = _.get(config, 'transformers', this.defaults.transformers)
      const privileged = this.hasFallbackPrivilege(req, options)

      if (fallbackMappings && privileged) {
        Object.keys(fallbackMappings).forEach(key => {
          let mappedValue = ''
          if (_.startsWith(fallbackMappings[key], 'legacy.')) {
            mappedValue = this.getParamSessionValue(req, fallbackMappings[key].substr(7), options)
          } else {
            mappedValue = this.getValueFromMappings(data, fallbackMappings[key])
          }

          const value = !!transformers[key] && !!this.util.transformFunctions[transformers[key]] ? this.util.transformFunctions[transformers[key]].call(mappedValue) : mappedValue
          if (value) {
            this.setFallbackValue(req, key, value, options)
          }
        })
      }
    }

    mapToHeaders(req, options = {}) {
      if (options.namespace) {
        Object.keys(_.get(req, `session.${this.name}['${options.namespace}']`, {})).forEach(key => {
          const val = _.get(req, `session.${this.name}['${options.namespace}'].${key}`)
          if (!_.isObject(val)) {
            this.setHeaderValue(req, key, val)
          }
        })

        Object.keys(_.get(req, `session.params['${options.namespace}']`, {})).forEach(key => {
          const val = _.get(req, `session.params['${options.namespace}'].${key}`)
          if (!_.isObject(val)) {
            this.setParamHeaderValue(req, key, val)
          }
        })
      } else {
        Object.keys(_.get(req, `session.${this.name}`, {})).forEach(key => {
          const val = _.get(req, `session.${this.name}.${key}`)
          if (!_.isObject(val)) {
            this.setHeaderValue(req, key, val)
          }
        })

        Object.keys(_.get(req, 'session.params', {})).forEach(key => {
          const val = _.get(req, `session.params.${key}`)
          if (!_.isObject(val)) {
            this.setParamHeaderValue(req, key, val)
          }
        })
      }
    }

    mapToSession(sessionData, req, config, options) {
      const params = this.getParams(req)
      const transformers = _.get(config, 'transformers', this.defaults.transformers)
      const authResponseMappings = _.get(config, 'mappings.authResponse', this.defaults.mappings.authResponse)
      const requestParamsMappings = _.get(config, 'mappings.requestParams', this.defaults.mappings.requestParams)

      Object.keys(authResponseMappings).forEach(key => {
        const mappedValue = this.getValueFromMappings(sessionData, authResponseMappings[key])
        const value = !!transformers[key] && !!this.util.transformFunctions[transformers[key]] ? this.util.transformFunctions[transformers[key]].call(mappedValue) : mappedValue
        this.setSessionValue(req, key, value, options)
      })

      if (requestParamsMappings.length) {
        requestParamsMappings.forEach(key => {
          if (params[key]) {
            const mappedValue = this.getValueFromMappings(params, key)
            const value = !!transformers[key] && !!this.util.transformFunctions[transformers[key]] ? this.util.transformFunctions[transformers[key]].call(mappedValue) : mappedValue
            this.setParamSessionValue(req, key, value, options)
          }
        })
      }
    }

    readBody(req, res, next, config) {
      const bodyOptions = {
        length: req.headers['content-length'],
        limit: '1mb',
        encoding: typer.parse(req.headers['content-type']).parameters.charset
      }

      try {
        getRawBody(req, bodyOptions, (err, body) => {
          if (err) {
            this.notAuthenticated(req, res, next, config)
          } else {

            req.rawBody = body
            req.body = querystring.parse(body.toString())

            Object.keys(req.body).forEach(key => {
              if (key.indexOf('custom_') === 0) {
                req.body[key.substring('custom_'.length)] = req.body[key]
              }
            })

            this.manageSession(req, res, next, config)
          }
        })
      } catch (err) {
        this.baseConfig.logger.error(err)
        this.notAuthenticated(req, res, next, config)
      }
    }

    setFallbackPrivilege(req, data, config, options = {}) {
      const privileged = _.reduce(_.get(config, 'privileged.fallback', []), (acc, value, key) => {
        return acc || Boolean(~value.indexOf(_.get(data, key)))
      }, false)

      if (privileged) {
        if (options.namespace) {
          _.set(req, `session.fallback['${options.namespace}'].privileged`, true)
        } else {
          _.set(req, 'session.fallback.privileged', true)
        }
      }
    }

    shouldRefresh(expiration, ttl = 3600) {
      if (_.isNaN(Number(expiration))) {
        return true
      } else {
        return (expiration - new Date().getTime()) < (ttl * 1000 * 0.2)
      }
    }

    truncateToken(token = '') {
      return token.substr(0, 12) + '...'
    }

    updateAndSaveSession(req, callback) {
      req.preserveSession(callback)
    }

    interceptor(config) {
      return (req, res, headers) => {
        if (!this.shouldRun) return

        if (headers[`${this.headerPrefix}-refresh`]) {
          this.manageSession(req, res, () => { return true }, config)
        } else if (headers[`${this.headerPrefix}-logout`]) {
          this.clearHeaders(req)
          req.preserveSession()
        }
      }
    }

    middleware() {
      return (req, res, next, config) => {
        if (!this.shouldRun) return next()

        config.mode = (config.mode) ? config.mode : 'allow'

        if (req.readable && !req.rawBody && config.post && req.method === 'POST' && req.headers['content-type']) {
          this.readBody(req, res, next, config)
        } else {
          this.manageSession(req, res, next, config)
        }
      }
    }

    /**
     * INTERFACES
     */

    clearSession(req = {}, options = {}) { }
    getClient() { }
    fetchAuth(req, res, next, config) { }
    manageSession(req, res, next, config) { }
    resumeSession(req, res, next, config) { }
  }
}
