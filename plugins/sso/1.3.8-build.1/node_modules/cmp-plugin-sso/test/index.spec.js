const expect = require('chai').expect
const http = require('http')
const Readable = require('stream').Readable
const sinon = require('sinon')
const Plugin = require('../index')
const _ = require('lodash')

describe('CMP Plugin: SSO', () => {

  describe('init', () => {

    it('should init with default property values set', () => {
      const plugin = new Plugin({})

      plugin.registerMode = sinon.spy()
      plugin.init()

      const expectedAuthResponseMappings = {
        'guid': 'data.guid',
        'role': 'data.userType',
        'first-name': 'user.givenName',
        'last-name': 'user.sn',
        'email': 'user.mail',
        'institution': 'user.tlinstitutionName',
        'institution-id': 'user.tlinstitutionId'
      }

      expect(plugin.registerMode.callCount).to.be.eql(1)
      expect(plugin.clients.length).to.be.eql(0)
      expect(plugin.defaults.mappings.authResponse).to.be.eql(expectedAuthResponseMappings)
    })
  })

  describe('trends', () => {

    it('should resolve trends data', () => {
      const plugin = new Plugin({})
      const req = {
        fetchHandlerTime: sinon.spy()
      }
      const res = {}
      const config = {}

      let resolver = null
      const p1 = new Promise((resolve) => {
        resolver = resolve
      })

      p1.then((data) => {
        expect(data).to.not.be.undefined
      })

      plugin.trends(config)(req, res, resolver)
    })
  })

  describe('getClient', () => {

    it('should return undefined if there is no endpoint in the config', () => {
      const plugin = new Plugin({})
      const config = {}

      const client = plugin.getClient(config)

      expect(client).to.be.undefined
    })

    it('should cache the client when a new one is created', () => {
      const plugin = new Plugin({})
      const config = {
        endpoint: 'http://endpoint'
      }

      const client = plugin.getClient(config)

      expect(client).to.eql(plugin.clients[config.endpoint])
    })

    it('should use return the client from the cache', () => {
      const plugin = new Plugin({})
      const fakeClient = 'fake client in cache'
      const config = {
        endpoint: 'http://endpoint'
      }

      plugin.clients[config.endpoint] = fakeClient
      const client = plugin.getClient(config)

      expect(client).to.eql(fakeClient)
    })
  })

  describe('handleAuthError', () => {

    it('should log the error and process unauthenticated', () => {
      const plugin = new Plugin({})
      const config = {}
      const req = {
        endHandlerTimer: sinon.spy(),
        header: sinon.spy()
      }

      plugin.baseConfig = {
        logger: {
          error: sinon.spy()
        }
      }

      plugin.notAuthenticated = sinon.spy()

      plugin.handleAuthError('token', {}, req, {}, function () { }, {})

      expect(req.endHandlerTimer.callCount).to.be.eql(1)
      expect(plugin.baseConfig.logger.error.callCount).to.be.eql(1)
      expect(plugin.notAuthenticated.callCount).to.be.eql(1)
      expect(req.header.callCount).to.eql(1)
    })
  })

  describe('handleAuthModeRedirect', () => {

    it('should process a secure intended redirect', () => {
      const plugin = new Plugin({})
      const config = {
        login: 'login.cengage.com',
        intended: true
      }
      const req = {
        url: 'cmp.cengage.info',
        query: '',
        headers: {
          'host': 'cmp.cengage.info',
          'x-forwarded-proto': 'https'
        }
      }
      const res = {
        redirect: sinon.spy()
      }

      plugin.handleAuthModeRedirect(req, res, function () { }, config)

      expect(res.redirect.callCount).to.be.eql(1)
    })

    it('should process an insecure intended redirect', () => {
      const plugin = new Plugin({})
      const config = {
        login: 'login.cengage.com',
        intended: true
      }
      const req = {
        url: 'cmp.cengage.info',
        query: '',
        headers: {
          'host': 'cmp.cengage.info'
        },
        protocol: 'http'
      }
      const res = {
        redirect: sinon.spy()
      }

      plugin.handleAuthModeRedirect(req, res, function () { }, config)

      expect(res.redirect.callCount).to.be.eql(1)
    })

    it('should process a basic redirect', () => {
      const plugin = new Plugin({})
      const config = {
        login: 'login.cengage.com'
      }
      const res = {
        redirect: sinon.spy()
      }

      plugin.handleAuthModeRedirect({}, res, function () { }, config)

      expect(res.redirect.callCount).to.be.eql(1)
    })
  })

  describe('fetchAuth', () => {

    it('should get a client and callback with the returned auth data', () => {
      const plugin = new Plugin({})
      const getUser = sinon.spy()

      sinon
        .stub(plugin, 'getClient')
        .returns({
          getUser
        })

      plugin.fetchAuth('token', {}, function () { })

      expect(plugin.getClient.callCount).to.be.eql(1)
      expect(getUser.callCount).to.be.eql(1)
    })
  })

  describe('manageSession', () => {

    it('should fetchAuth if given a token, and handle errors', () => {
      const plugin = new Plugin({})
      const err = true
      const req = {
        startHandlerTimer: sinon.spy()
      }
      const authData = {
        resultCode: 401
      }

      sinon.stub(plugin, 'getRequestToken').returns('myToken')
      sinon.stub(plugin, 'getExpiringToken').returns('')
      sinon.stub(plugin, 'fetchAuth').callsArgWith(2, err, authData)

      plugin.clearSession = sinon.spy()
      plugin.handleAuthError = sinon.spy()
      plugin.mapToSession = sinon.spy()

      plugin.manageSession(req)

      expect(req.startHandlerTimer.callCount).to.be.eql(1)
      expect(req.isAuthenticated).to.be.undefined
      expect(req.isLoggingIn).to.be.undefined
      expect(plugin.clearSession.callCount).to.be.eql(1)
      expect(plugin.handleAuthError.callCount).to.be.eql(1)
      expect(plugin.mapToSession.callCount).to.be.eql(0)
    })

    it('should fetchAuth if given a token, and handle success', () => {
      const plugin = new Plugin({})
      const err = false
      const req = {
        startHandlerTimer: sinon.spy(),
        endHandlerTimer: sinon.spy(),
        sessionCookie: {},
        preserveSession: sinon.spy(),
        mergeSession: sinon.spy(),
        header: sinon.spy()
      }
      const res = {
        cookie: sinon.spy()
      }
      const authData = {
        resultCode: 0,
        token: 'abc123',
        guid: 'my-guid'
      }

      sinon.stub(plugin, 'getRequestToken').returns('myToken')
      sinon.stub(plugin, 'getExpiringToken').returns('')
      sinon.stub(plugin, 'fetchAuth').callsArgWith(2, err, authData)

      plugin.getParams = sinon.spy()
      plugin.getNamespace = sinon.spy()
      plugin.clearSession = sinon.spy()
      plugin.handleAuthError = sinon.spy()
      plugin.getExpiration = sinon.spy()
      plugin.mapToSession = sinon.spy()
      plugin.setSessionValue = sinon.spy()
      plugin.setFallbackPrivilege = sinon.spy()
      plugin.mapFallbacksToSession = sinon.spy()

      plugin.manageSession(req, res, function () { }, {})

      expect(req.startHandlerTimer.callCount).to.be.eql(1)
      expect(req.isAuthenticated).to.be.true
      expect(req.isLoggingIn).to.be.true
      expect(req.sessionCookie.sso.guid).to.be.eql('my-guid')
      expect(req.endHandlerTimer.callCount).to.be.eql(1)
      expect(req.preserveSession.callCount).to.be.eql(1)
      expect(plugin.clearSession.callCount).to.be.eql(1)
      expect(plugin.handleAuthError.callCount).to.be.eql(0)
      expect(plugin.getParams.callCount).to.be.eql(1)
      expect(plugin.getNamespace.callCount).to.be.eql(1)
      expect(plugin.getExpiration.callCount).to.be.eql(1)
      expect(plugin.mapToSession.callCount).to.be.eql(1)
      expect(plugin.setSessionValue.callCount).to.be.eql(4)
      expect(plugin.setFallbackPrivilege.callCount).to.be.eql(1)
      expect(plugin.mapFallbacksToSession.callCount).to.be.eql(1)
    })

    it('should fetchAuth with an expiring token, set the refresh header, and handle success', () => {
      const plugin = new Plugin({})
      const err = false
      const req = {
        startHandlerTimer: sinon.spy(),
        endHandlerTimer: sinon.spy(),
        mergeSession: sinon.spy(),
        preserveSession: sinon.spy(),
        header: sinon.spy()
      }
      const res = {
        cookie: sinon.spy()
      }
      const authData = {
        resultCode: 0,
        token: 'abc123'
      }

      sinon.stub(plugin, 'getRequestToken').returns('')
      sinon.stub(plugin, 'getExpiringToken').returns('myToken')
      sinon.stub(plugin, 'fetchAuth').callsArgWith(2, err, authData)

      plugin.getParams = sinon.spy()
      plugin.getNamespace = sinon.spy()
      plugin.clearSession = sinon.spy()
      plugin.handleAuthError = sinon.spy()
      plugin.getExpiration = sinon.spy()
      plugin.mapToSession = sinon.spy()
      plugin.setSessionValue = sinon.spy()
      plugin.setFallbackPrivilege = sinon.spy()
      plugin.mapFallbacksToSession = sinon.spy()

      plugin.manageSession(req, res, function () { }, {})

      expect(req.startHandlerTimer.callCount).to.be.eql(1)
      expect(req.endHandlerTimer.callCount).to.be.eql(1)
      expect(req.isAuthenticated).to.be.true
      expect(req.isLoggingIn).to.be.true
      expect(req.preserveSession.callCount).to.be.eql(1)
      expect(plugin.clearSession.callCount).to.be.eql(1)
      expect(plugin.handleAuthError.callCount).to.be.eql(0)
      expect(plugin.getParams.callCount).to.be.eql(1)
      expect(plugin.getNamespace.callCount).to.be.eql(1)
      expect(plugin.getExpiration.callCount).to.be.eql(1)
      expect(plugin.mapToSession.callCount).to.be.eql(1)
      expect(plugin.setSessionValue.callCount).to.be.eql(4)
      expect(plugin.setFallbackPrivilege.callCount).to.be.eql(1)
      expect(plugin.mapFallbacksToSession.callCount).to.be.eql(1)
      expect(req.headers['cengage-sso-refresh']).to.be.eql(true)
    })

    it('should clear session completely if guid doesn\'t match the saved one', () => {
      const plugin = new Plugin({})
      const err = false
      const req = {
        startHandlerTimer: sinon.spy(),
        endHandlerTimer: sinon.spy(),
        mergeSession: sinon.spy(),
        preserveSession: sinon.spy(),
        header: sinon.spy()
      }
      const res = {}
      const authData = {
        resultCode: 0,
        token: 'abc123',
        guid: 'abc'
      }

      sinon.stub(plugin, 'getRequestToken').returns('myToken')
      sinon.stub(plugin, 'getExpiringToken').returns('')
      sinon.stub(plugin, 'fetchAuth').callsArgWith(2, err, authData)
      sinon.stub(plugin, 'getGuidFromSession').returns('notMyGuid')

      plugin.getParams = sinon.spy()
      plugin.getNamespace = sinon.spy()
      plugin.clearSession = sinon.spy()
      plugin.clearSessionForceful = sinon.spy()
      plugin.handleAuthError = sinon.spy()
      plugin.getExpiration = sinon.spy()
      plugin.mapToSession = sinon.spy()
      plugin.setSessionValue = sinon.spy()
      plugin.setFallbackPrivilege = sinon.spy()
      plugin.mapFallbacksToSession = sinon.spy()

      plugin.manageSession(req, res, function () { }, {})

      expect(req.startHandlerTimer.callCount).to.be.eql(1)
      expect(req.endHandlerTimer.callCount).to.be.eql(1)
      expect(req.isAuthenticated).to.be.true
      expect(req.isLoggingIn).to.be.true
      expect(req.sessionCookie.sso.guid).to.be.eql('abc')
      expect(req.preserveSession.callCount).to.be.eql(1)
      expect(plugin.clearSession.callCount).to.be.eql(1)
      expect(plugin.clearSessionForceful.callCount).to.be.eql(1)
      expect(plugin.handleAuthError.callCount).to.be.eql(0)
      expect(plugin.getParams.callCount).to.be.eql(1)
      expect(plugin.getNamespace.callCount).to.be.eql(1)
      expect(plugin.getExpiration.callCount).to.be.eql(1)
      expect(plugin.mapToSession.callCount).to.be.eql(1)
      expect(plugin.setSessionValue.callCount).to.be.eql(4)
      expect(plugin.setFallbackPrivilege.callCount).to.be.eql(1)
      expect(plugin.mapFallbacksToSession.callCount).to.be.eql(1)
    })

    it('should clear session cookie completely if guid doesn\'t match the saved one', () => {
      const plugin = new Plugin({})
      const err = false
      const req = {
        startHandlerTimer: sinon.spy(),
        endHandlerTimer: sinon.spy(),
        mergeSession: sinon.spy(),
        preserveSession: sinon.spy(),
        header: sinon.spy()
      }
      const res = {}
      const authData = {
        resultCode: 0,
        token: 'abc123',
        guid: 'abc'
      }

      sinon.stub(plugin, 'getRequestToken').returns('myToken')
      sinon.stub(plugin, 'getExpiringToken').returns('')
      sinon.stub(plugin, 'fetchAuth').callsArgWith(2, err, authData)
      sinon.stub(plugin, 'getGuidFromSession').returns('notMyGuid')

      plugin.getParams = sinon.spy()
      plugin.getNamespace = sinon.spy()
      plugin.clearSession = sinon.spy()
      plugin.clearSessionForceful = sinon.spy()
      plugin.clearSessionCookieForceful = sinon.spy()
      plugin.handleAuthError = sinon.spy()
      plugin.getExpiration = sinon.spy()
      plugin.mapToSession = sinon.spy()
      plugin.setSessionValue = sinon.spy()
      plugin.setFallbackPrivilege = sinon.spy()
      plugin.mapFallbacksToSession = sinon.spy()

      plugin.manageSession(req, res, function () { }, {})

      expect(req.startHandlerTimer.callCount).to.be.eql(1)
      expect(req.endHandlerTimer.callCount).to.be.eql(1)
      expect(req.isAuthenticated).to.be.true
      expect(req.isLoggingIn).to.be.true
      expect(req.sessionCookie.sso.guid).to.be.eql('abc')
      expect(req.preserveSession.callCount).to.be.eql(1)
      expect(plugin.clearSession.callCount).to.be.eql(1)
      expect(plugin.clearSessionForceful.callCount).to.be.eql(1)
      expect(plugin.clearSessionCookieForceful.callCount).to.be.eql(1)
      expect(plugin.handleAuthError.callCount).to.be.eql(0)
      expect(plugin.getParams.callCount).to.be.eql(1)
      expect(plugin.getNamespace.callCount).to.be.eql(1)
      expect(plugin.getExpiration.callCount).to.be.eql(1)
      expect(plugin.mapToSession.callCount).to.be.eql(1)
      expect(plugin.setSessionValue.callCount).to.be.eql(4)
      expect(plugin.setFallbackPrivilege.callCount).to.be.eql(1)
      expect(plugin.mapFallbacksToSession.callCount).to.be.eql(1)
    })

    it('should not clear session completely if guid matches the saved one', () => {
      const plugin = new Plugin({})
      const err = false
      const req = {
        startHandlerTimer: sinon.spy(),
        endHandlerTimer: sinon.spy(),
        mergeSession: sinon.spy(),
        preserveSession: sinon.spy(),
        header: sinon.spy()
      }
      const res = {}
      const authData = {
        resultCode: 0,
        token: 'abc123',
        guid: 'abc'
      }

      sinon.stub(plugin, 'getRequestToken').returns('myToken')
      sinon.stub(plugin, 'getExpiringToken').returns('')
      sinon.stub(plugin, 'fetchAuth').callsArgWith(2, err, authData)
      sinon.stub(plugin, 'getGuidFromSession').returns('abc')

      plugin.getParams = sinon.spy()
      plugin.getNamespace = sinon.spy()
      plugin.clearSession = sinon.spy()
      plugin.clearSessionForceful = sinon.spy()
      plugin.handleAuthError = sinon.spy()
      plugin.getExpiration = sinon.spy()
      plugin.mapToSession = sinon.spy()
      plugin.setSessionValue = sinon.spy()
      plugin.setFallbackPrivilege = sinon.spy()
      plugin.mapFallbacksToSession = sinon.spy()

      plugin.manageSession(req, res, function () { }, {})

      expect(req.startHandlerTimer.callCount).to.be.eql(1)
      expect(req.endHandlerTimer.callCount).to.be.eql(1)
      expect(req.preserveSession.callCount).to.be.eql(1)
      expect(plugin.clearSession.callCount).to.be.eql(1)
      expect(plugin.clearSessionForceful.callCount).to.be.eql(0)
      expect(plugin.handleAuthError.callCount).to.be.eql(0)
      expect(plugin.getParams.callCount).to.be.eql(1)
      expect(plugin.getNamespace.callCount).to.be.eql(1)
      expect(plugin.getExpiration.callCount).to.be.eql(1)
      expect(plugin.mapToSession.callCount).to.be.eql(1)
      expect(plugin.setSessionValue.callCount).to.be.eql(4)
      expect(plugin.setFallbackPrivilege.callCount).to.be.eql(1)
      expect(plugin.mapFallbacksToSession.callCount).to.be.eql(1)
    })

    it('should pass through if authenticated but no token given', () => {
      const plugin = new Plugin({})
      const next = sinon.spy()
      const req = {
        header: sinon.spy()
      }

      sinon.stub(plugin, 'getRequestToken').returns('')
      sinon.stub(plugin, 'getExpiringToken').returns('')
      sinon.stub(plugin, 'isAuth').returns(true)


      plugin.manageSession(req, {}, next)

      expect(next.callCount).to.be.eql(1)
    })

    it('should handle notAuthenticated if unable to find a token', () => {
      const plugin = new Plugin({})
      _.set(plugin, 'baseConfig.version', '5.1.0')

      sinon.stub(plugin, 'getRequestToken').returns('')
      sinon.stub(plugin, 'getExpiringToken').returns('')
      plugin.notAuthenticated = sinon.spy()

      plugin.manageSession()

      expect(plugin.notAuthenticated.callCount).to.be.eql(1)
    })
  })

  describe('resumeSession', () => {

    it('should mapHeaders with config and call next', () => {
      const plugin = new Plugin({})
      const req = {}
      const next = sinon.spy()

      plugin.mapToHeaders = sinon.spy()

      plugin.resumeSession(req, {}, next, {})

      expect(plugin.mapToHeaders.callCount).to.be.eql(1)
      expect(req.isAuthenticated).to.be.true
      expect(next.callCount).to.be.eql(1)
      expect(plugin.mapToHeaders.getCall(0).args).to.be.eql([ req, {} ])
    })
  })

  describe('clear session', () => {

    it('clearSessionForceful should empty out req.session', () => {
      const plugin = new Plugin({})
      const req = {
        session: {
          guid: 'xyz',
          otherThing: 'idk'
        }
      }

      plugin.clearSessionForceful(req)

      expect(req.session).to.eql({})
    })

    it('clearSessionCookieForceful should empty out req.sessionCookie', () => {
      const plugin = new Plugin({})
      const req = {
        sessionCookie: {
          sso: {
            guid: 'xyz'
          }
        }
      }

      plugin.clearSessionCookieForceful(req)

      expect(req.sessionCookie).to.eql({})
    })
  })

  describe('mapToSession', () => {
    it('should map request params based on mappings and run through transforms, sessionData is copied as is to sso_meta', () => {
      const plugin = new Plugin({})
      const req = {
        header: sinon.spy(),
        session: {
          authentication: {}
        }
      }

      const config = {
        transformers: {
          'firstName': 'lower',
          'shouldBeUpperCase': 'upper'
        },
        mappings: {
          requestParams: [ 'courseKey', 'intentionallyMissing', 'shouldBeUpperCase' ]
        }
      }

      const sessionData = {
        token: 'myToken',
        user: {
          firstname: 'myFirstNameShouldBeLowerCase',
          lastname: 'myLastName',
          anotherThing: {
            'someKey': 'someVal'
          }
        }
      }

      plugin.init()

      sinon
        .stub(plugin, 'getParams')
        .returns({
          courseKey: 'myCourseKey',
          shouldBeUpperCase: 'myParamShouldBeUpperCase',
          notNeededKey: 'shouldNotBeMapped'
        })

      plugin.mapToSession(sessionData, req, config)

      expect(req.session['sso_meta'].token).to.be.eql(sessionData.token)
      expect(req.session['sso_meta'].user).to.be.eql(sessionData.user)
      expect(req.session.params.courseKey).to.be.eql('myCourseKey')
      expect(req.session.params.shouldBeUpperCase).to.be.eql('MYPARAMSHOULDBEUPPERCASE')
      expect(req.session.params.notNeededKey).to.be.eql(undefined)
      expect(req.session.params.intentionallyMissing).to.be.eql(undefined)
    })

    it('should map request params based on mappings and run through transforms, sessionData is copied as is to sso_meta', () => {
      const plugin = new Plugin({})
      const req = {
        header: sinon.spy(),
        session: {
          authentication: {}
        }
      }

      const config = {
        transformers: {
          'firstName': 'lower',
          'shouldBeUpperCase': 'upper'
        },
        mappings: {
          requestParams: [ 'courseKey', 'intentionallyMissing', 'shouldBeUpperCase' ]
        }
      }

      const sessionData = {
        token: 'myToken',
        user: {
          firstname: 'myFirstNameShouldBeLowerCase',
          lastname: 'myLastName',
          anotherThing: {
            'someKey': 'someVal'
          }
        }
      }

      plugin.init()

      sinon
        .stub(plugin, 'getParams')
        .returns({
          courseKey: 'myCourseKey',
          shouldBeUpperCase: 'myParamShouldBeUpperCase',
          notNeededKey: 'shouldNotBeMapped'
        })

      plugin.mapToSession(sessionData, req, config)

      expect(req.session['sso_meta'].token).to.be.eql(sessionData.token)
      expect(req.session['sso_meta'].user).to.be.eql(sessionData.user)
      expect(req.session.params.courseKey).to.be.eql('myCourseKey')
      expect(req.session.params.shouldBeUpperCase).to.be.eql('MYPARAMSHOULDBEUPPERCASE')
      expect(req.session.params.notNeededKey).to.be.eql(undefined)
      expect(req.session.params.intentionallyMissing).to.be.eql(undefined)
    })

    it('should map a data structure to session variables', () => {
      const plugin = new Plugin({})
      const req = {
        header: sinon.spy(),
        session: {
          sso: {}
        }
      }

      const config = {
        transformers: {
          'firstName': 'lower',
          'shouldBeUpperCase': 'upper'
        },
        mappings: {
          requestParams: [ 'courseKey', 'intentionallyMissing', 'shouldBeUpperCase' ],
          authResponse: {
            token: 'token',
            firstName: 'user.firstname',
            lastName: 'user.lastname'
          }
        }
      }

      const sessionData = {
        token: 'myToken',
        user: {
          firstname: 'myFirstNameShouldBeLowerCase',
          lastname: 'myLastName'
        }
      }

      plugin.init()

      sinon
        .stub(plugin, 'getParams')
        .returns({
          courseKey: 'myCourseKey',
          shouldBeUpperCase: 'myParamShouldBeUpperCase',
          notNeededKey: 'shouldNotBeMapped'
        })

      plugin.mapToSession(sessionData, req, config)

      expect(req.session.sso.token).to.be.eql('myToken')
      expect(req.session.sso.firstName).to.be.eql('myfirstnameshouldbelowercase')
      expect(req.session.sso.lastName).to.be.eql('myLastName')
      expect(req.session.params.courseKey).to.be.eql('myCourseKey')
      expect(req.session.params.shouldBeUpperCase).to.be.eql('MYPARAMSHOULDBEUPPERCASE')
      expect(req.session.params.notNeededKey).to.be.eql(undefined)
      expect(req.session.params.intentionallyMissing).to.be.eql(undefined)
    })
  })

  describe('clearSession', () => {
    it('should wipe session data with no namespace', () => {
      const plugin = new Plugin({})
      const req = {
        header: (headerName) => {
          return 'myhost'
        },
        session: {
          headers: {
            'cengage-sso-clearMe': true
          },
          sso: {
            clearMe: true
          },
          sso_meta: {
            someData: {},
            user: { 'name': 'derp' }
          }
        }
      }

      plugin.init()
      plugin.clearSession(req)

      expect(req.session.sso).to.be.eql({})
      expect(req.session['sso_meta']).to.be.eql({})
    })

    it('should clear ssoVersion from host in mappings', () => {
      const plugin = new Plugin({})
      const req = {
        header: (headerName) => {
          return 'myhost'
        },
        session: {
          headers: {
            'cengage-sso-clearMe': true
          },
          sso: {
            clearMe: true
          },
          sso_meta: {
            someData: {},
            user: { 'name': 'derp' }
          },
          mappings: {
            myhost: {
              ssoVersion: '1.5.0'
            }
          }
        }
      }

      plugin.init()
      plugin.clearSession(req)

      expect(req.session.mappings.myhost).to.be.eql({})
    })
  })

  describe('mapToHeaders', () => {

    it('should map session headers from req.session.sso_meta and apply transforms when version mapping exists', () => {
      const plugin = new Plugin({})
      const config = {
        transformers: {
          'firstName': 'lower'
        },
        mappings: {
          authResponse: {
            token: 'token',
            firstName: 'user.firstname',
            lastName: 'user.lastname'
          }
        }
      }
      const req = {
        header: sinon.stub().returns('someHost'),
        session: {
          mappings: {
            someHost: {
              ssoVersion: 'thisVersion'
            }
          },
          sso_meta: {
            token: 'myToken',
            user: {
              firstname: 'myFirstNameShouldBeLowerCase',
              lastname: 'myLastName'
            }
          }
        }
      }

      plugin.init()
      plugin.mapToHeaders(req, config)

      expect(req.session.headers['cengage-sso-token']).to.be.eql('myToken')
      expect(req.session.headers['cengage-sso-firstName']).to.be.eql('myfirstnameshouldbelowercase')
      expect(req.session.headers['cengage-sso-lastName']).to.be.eql('myLastName')
    })

    it('should map session headers from req.session.sso_meta with missing values and apply transforms when version mapping exists', () => {
      const plugin = new Plugin({})
      const config = {
        transformers: {
          'firstName': 'lower'
        },
        mappings: {
          authResponse: {
            token: 'token',
            firstName: 'user.firstname',
            lastName: 'user.lastname'
          }
        }
      }
      const req = {
        header: sinon.stub().returns('someHost'),
        session: {
          mappings: {
            someHost: {
              ssoVersion: 'thisVersion'
            }
          },
          sso_meta: {
            user: {
              firstname: 'myFirstNameShouldBeLowerCase',
              lastname: 'myLastName'
            }
          }
        }
      }

      plugin.init()
      plugin.mapToHeaders(req, config)

      expect(req.session.headers['cengage-sso-firstName']).to.be.eql('myfirstnameshouldbelowercase')
      expect(req.session.headers['cengage-sso-lastName']).to.be.eql('myLastName')
    })

    it('should map request params from req.session.params as is (with proper prefix)', () => {
      const plugin = new Plugin({})
      const req = {
        header: sinon.spy(),
        session: {
          sso: {
            token: 'myToken',
            user: {
              firstname: 'myFirstNameShouldBeLowerCase',
              lastname: 'myLastName'
            }
          },
          params: {
            courseKey: 'myCourseKey'
          }
        }
      }

      plugin.init()
      plugin.mapToHeaders(req)

      expect(req.session.headers['cmp-dynamic-courseKey']).to.be.eql('myCourseKey')
    })
  })
})
