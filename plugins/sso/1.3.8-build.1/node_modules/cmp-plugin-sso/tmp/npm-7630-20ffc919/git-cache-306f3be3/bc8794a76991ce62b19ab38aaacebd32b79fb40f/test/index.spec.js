const expect = require('chai').expect
const http = require('http')
const Readable = require('stream').Readable
const sinon = require('sinon')
const Plugin = require('../index')({ name: 'cmp-plugin-authentication' })
const _ = require('lodash')

describe('CMP Plugin: Authentication', () => {

  describe('init', () => {

    it('should init with default property values set', () => {
      const plugin = new Plugin({})

      plugin.init()

      expect(plugin.headerPrefix).to.be.equals('cengage-sso')
      expect(plugin.defaults.mappings.requestParams).to.deep.equals([])
      expect(plugin.defaults.mappings.authResponse).to.deep.equals({})
      expect(plugin.name).to.be.equals('authentication')

      expect(plugin.authModes).to.deep.equals([ 'allow', 'restrict' ])
    })
  })

  describe('static get level', () => {

    it('should return the static defined level value', () => {
      expect(Plugin.level).to.be.equals(1000)
    })
  })

  describe('children', () => {

    it('should populate post and mode values on children', () => {
      const plugin = new Plugin({})

      plugin.init()

      const childs = plugin.children({
        post: {
          paths: [
            '/post'
          ]
        },
        allow: {
          paths: [
            '/allow'
          ]
        }
      })

      expect(childs['/post'].post).to.be.eql(true)
      expect(childs['/allow'].mode).to.be.eql('allow')
    })
  })

  describe('registerMode', () => {

    it('should add a new mode to the mappings', () => {
      const plugin = new Plugin({})

      plugin.init()
      plugin.registerMode('testMode', function () { })

      expect(plugin.authHandlers.testMode).to.be.a('function')
      expect(plugin.authModes.indexOf('testMode')).to.be.gt(-1)
    })
  })

  describe('shouldRun', () => {

    it('should return true for now', () => {
      const plugin = new Plugin({})

      plugin.init()

      expect(plugin.shouldRun()).to.be.eql(true)
    })
  })

  describe('clearHeaders', () => {

    it('should wipe header data', () => {
      const plugin = new Plugin({})
      const req = {
        session: {
          headers: {
            'cengage-sso-clearMe': true
          },
          authentication: {
            clearMe: true
          }
        }
      }

      plugin.init()
      plugin.clearHeaders(req)

      expect(req.session.headers['cengage-sso-clearMe']).to.be.eql(undefined)
    })

    it('should handle no req object', () => {
      const plugin = new Plugin({})
      const req = {
        session: {}
      }

      plugin.init()

      expect(plugin.clearHeaders()).to.be.eql({ session: { headers: {} } })
    })
  })

  describe('getHeaderValue', () => {

    it('should return a header value', () => {
      const plugin = new Plugin({})
      const req = {
        session: {
          headers: {
            'cengage-sso-test': true
          }
        }
      }

      plugin.init()

      expect(plugin.getHeaderValue(req, 'test')).to.be.eql(true)
    })
  })

  describe('getSessionValue', () => {

    it('should return a session value', () => {
      const plugin = new Plugin({})
      const req = {
        session: {
          authentication: {
            test: true
          }
        }
      }

      plugin.init()

      expect(plugin.getSessionValue(req, 'test')).to.be.eql(true)
    })

    it('should return a namespaced session value', () => {
      const plugin = new Plugin({})
      const opts = {
        namespace: 'my.namespace'
      }
      const req = {
        session: {
          authentication: {
            'my.namespace': {
              test: true
            }
          }
        }
      }

      plugin.init()

      expect(plugin.getSessionValue(req, 'test', opts)).to.be.eql(true)
    })
  })

  describe('getFallbackValue', () => {

    it('should return a fallback value', () => {
      const plugin = new Plugin({})
      const req = {
        session: {
          fallback: {
            test: true
          }
        }
      }

      plugin.init()

      expect(plugin.getFallbackValue(req, 'test')).to.be.eql(true)
    })

    it('should return a namespaced fallback value', () => {
      const plugin = new Plugin({})
      const opts = {
        namespace: 'my.namespace'
      }
      const req = {
        session: {
          fallback: {
            'my.namespace': {
              test: true
            }
          }
        }
      }

      plugin.init()

      expect(plugin.getFallbackValue(req, 'test', opts)).to.be.eql(true)
    })
  })

  describe('setHeaderValue', () => {

    it('should set a header value', () => {
      const plugin = new Plugin({})
      const req = {
        session: {
          headers: {}
        }
      }

      plugin.init()
      plugin.setHeaderValue(req, 'test', true)
      plugin.setHeaderValue(req, 'string', ' ')

      expect(plugin.getHeaderValue(req, 'test')).to.be.eql(true)
      expect(plugin.getHeaderValue(req, 'string')).to.be.eql(' ')
    })

    it('should remove a header value', () => {
      const plugin = new Plugin({})
      const req = {
        session: {
          headers: {}
        }
      }

      plugin.init()
      plugin.setHeaderValue(req, 'test', null)

      expect(plugin.getHeaderValue(req, 'test')).to.be.eql(undefined)
    })
  })

  describe('setSessionValue', () => {

    it('should set session data', () => {
      const plugin = new Plugin({})
      const req = {
        session: {
          authentication: {}
        }
      }

      plugin.init()
      plugin.setSessionValue(req, 'test', true)

      expect(req.session.authentication.test).to.be.eql(true)
    })

    it('should remove session data if passed in null', () => {
      const plugin = new Plugin({})
      const req = {
        session: {
          authentication: {
            test: true
          }
        }
      }

      plugin.init()
      plugin.setSessionValue(req, 'test', null)

      expect(req.session.authentication.test).to.be.eql(undefined)
    })

    it('should set a namespaced session value', () => {
      const plugin = new Plugin({})
      const opts = {
        namespace: 'my.namespace'
      }
      const req = {
        session: {
          authentication: {}
        }
      }

      plugin.init()
      plugin.setSessionValue(req, 'test', true, opts)

      expect(req.session.authentication['my.namespace'].test).to.be.eql(true)
    })
  })

  describe('setFallbackValue', () => {

    it('should set session data', () => {
      const plugin = new Plugin({})
      const req = {
        session: {
          fallback: {}
        }
      }

      plugin.init()
      plugin.setFallbackValue(req, 'test', true)

      expect(req.session.fallback.test).to.be.eql(true)
    })

    it('should remove session data if passed in null', () => {
      const plugin = new Plugin({})
      const req = {
        session: {
          fallback: {
            test: true
          }
        }
      }

      plugin.init()
      plugin.setFallbackValue(req, 'test', null)

      expect(req.session.fallback.test).to.be.eql(undefined)
    })

    it('should set a namespaced session value', () => {
      const plugin = new Plugin({})
      const opts = {
        namespace: 'my.namespace'
      }
      const req = {
        session: {
          fallback: {}
        }
      }

      plugin.init()
      plugin.setFallbackValue(req, 'test', true, opts)

      expect(req.session.fallback['my.namespace'].test).to.be.eql(true)
    })
  })

  describe('getParamHeaderValue', () => {

    it('should return a param header value', () => {
      const plugin = new Plugin({})
      const req = {
        session: {
          headers: {
            'cmp-dynamic-test': true
          }
        }
      }

      plugin.init()

      expect(plugin.getParamHeaderValue(req, 'test')).to.be.eql(true)
    })
  })

  describe('getParamSessionValue', () => {

    it('should return a param session value', () => {
      const plugin = new Plugin({})
      const req = {
        session: {
          params: {
            test: true
          }
        }
      }

      plugin.init()

      expect(plugin.getParamSessionValue(req, 'test')).to.be.eql(true)
    })

    it('should return a namespaced param session value', () => {
      const plugin = new Plugin({})
      const opts = {
        namespace: 'my.namespace'
      }
      const req = {
        session: {
          params: {
            'my.namespace': {
              test: true
            }
          }
        }
      }

      plugin.init()

      expect(plugin.getParamSessionValue(req, 'test', opts)).to.be.eql(true)
    })
  })

  describe('setParamHeaderValue', () => {

    it('should set a param header value', () => {
      const plugin = new Plugin({})
      const req = {
        session: {
          headers: {}
        }
      }

      plugin.init()
      plugin.setParamHeaderValue(req, 'test', true)

      expect(plugin.getParamHeaderValue(req, 'test')).to.be.eql(true)
    })

    it('should remove a param header value', () => {
      const plugin = new Plugin({})
      const req = {
        session: {
          headers: {}
        }
      }

      plugin.init()
      plugin.setParamHeaderValue(req, 'test', null)

      expect(plugin.getParamHeaderValue(req, 'test')).to.be.eql(undefined)
    })
  })

  describe('setParamSessionValue', () => {

    it('should set param session data', () => {
      const plugin = new Plugin({})
      const req = {
        session: {
          params: {}
        }
      }

      plugin.init()
      plugin.setParamSessionValue(req, 'test', true)

      expect(req.session.params.test).to.be.eql(true)
    })

    it('should remove param session data if given null as value', () => {
      const plugin = new Plugin({})
      const req = {
        session: {
          params: {
            test: true
          }
        }
      }

      plugin.init()
      plugin.setParamSessionValue(req, 'test', null)

      expect(req.session.params.test).to.be.eql(undefined)
    })

    it('should set a namespaced param session value', () => {
      const plugin = new Plugin({})
      const opts = {
        namespace: 'my.namespace'
      }
      const req = {
        session: {
          params: {}
        }
      }

      plugin.init()
      plugin.setParamSessionValue(req, 'test', true, opts)

      expect(req.session.params['my.namespace'].test).to.be.eql(true)
    })
  })

  describe('handleAuthMode', () => {

    it('should call a registered mode handler', () => {
      const plugin = new Plugin({})

      plugin.handleAuthModeAllow = sinon.spy()
      plugin.handleAuthModeRestrict = sinon.spy()

      plugin.init()

      plugin.handleAuthMode({}, {}, {}, { mode: 'allow' })
      plugin.handleAuthMode({}, {}, {}, { mode: 'restrict' })

      expect(plugin.handleAuthModeAllow.callCount).to.eql(1)
      expect(plugin.handleAuthModeRestrict.callCount).to.eql(1)
    })

    it('should log a warning if bad mode handler', () => {
      const plugin = new Plugin({})
      const token = 'myAuthToken'

      plugin.baseConfig = { logger: { warn: sinon.spy() } }

      sinon
        .stub(plugin, 'getParams')
        .returns({
          token: token
        })

      const headerSpy = sinon.spy()
      plugin.handleAuthModeAllow = sinon.spy()
      plugin.handleAuthModeRestrict = sinon.spy()

      plugin.init()

      plugin.handleAuthMode({ header: headerSpy }, {}, {}, { mode: 'unregisteredMode' })

      expect(plugin.handleAuthModeAllow.callCount).to.eql(0)
      expect(plugin.handleAuthModeRestrict.callCount).to.eql(0)
      expect(plugin.baseConfig.logger.warn.callCount).to.eql(1)
      expect(headerSpy.callCount).to.eql(1)
    })

    it('should log a warning if no mode handler', () => {
      const plugin = new Plugin({})
      const token = 'myAuthToken'

      plugin.baseConfig = { logger: { warn: sinon.spy() } }

      sinon
        .stub(plugin, 'getParams')
        .returns({
          token: token
        })

      const headerSpy = sinon.spy()
      plugin.handleAuthModeAllow = sinon.spy()
      plugin.handleAuthModeRestrict = sinon.spy()

      plugin.init()

      plugin.handleAuthMode({ header: headerSpy }, {}, {}, {})

      expect(plugin.handleAuthModeAllow.callCount).to.eql(0)
      expect(plugin.handleAuthModeRestrict.callCount).to.eql(0)
      expect(plugin.baseConfig.logger.warn.callCount).to.eql(1)
      expect(headerSpy.callCount).to.eql(1)
    })
  })

  describe('handleAuthModeAllow', () => {

    it('should allow the user to continue', () => {
      const plugin = new Plugin({})
      const next = sinon.spy()

      plugin.init()
      plugin.handleAuthModeAllow({}, {}, next)


      expect(next.calledOnce).to.eql(true)
    })
  })

  describe('handleAuthModeRestrict', () => {

    it('should restrict the user from continuing', () => {
      const plugin = new Plugin({})
      const end = sinon.spy()

      plugin.init()
      plugin.handleAuthModeRestrict({}, {
        location: function () {
          return {
            status: function () {
              return {
                end
              }
            }
          }
        }
      }, null, {})


      expect(end.calledOnce).to.eql(true)
    })
  })

  describe('getNamespace', () => {

    it('should return the courseCgi namespace from params', () => {
      const plugin = new Plugin({})

      expect(plugin.getNamespace({ courseCgi: '123' })).to.be.eql('cgi:123')
    })

    it('should return the courseKey namespace from params', () => {
      const plugin = new Plugin({})

      expect(plugin.getNamespace({ courseKey: '123' })).to.be.eql('key:123')
    })

    it('should return no namespace if no params given', () => {
      const plugin = new Plugin({})

      expect(plugin.getNamespace()).to.be.eql('')
    })

    it('should return the courseKey namespace from params with periods', () => {
      const plugin = new Plugin({})

      expect(plugin.getNamespace({ courseKey: '123.MT.moardots' })).to.be.eql('key:123.MT.moardots')
    })
  })

  describe('notAuthenticated', () => {

    it('should clear the headers and push the request through the mode handlers', () => {
      const plugin = new Plugin({})
      const req = {}
      plugin.clearHeaders = sinon.spy()
      plugin.handleAuthMode = sinon.spy()

      plugin.init()
      plugin.notAuthenticated(req)

      expect(plugin.clearHeaders.calledOnce).to.eql(true)
      expect(plugin.handleAuthMode.calledOnce).to.eql(true)
    })
  })

  describe('getExpiration', () => {

    it('should return a future expiration time', () => {
      const plugin = new Plugin({})

      plugin.init()

      expect(plugin.getExpiration()).to.be.gt(new Date().getTime())
    })

    it('should return a future expiration time with a custom ttl', () => {
      const plugin = new Plugin({})

      plugin.init()

      expect(plugin.getExpiration(10000)).to.be.gt(new Date().getTime() + 3600 * 1000)
    })
  })

  describe('getExpiringToken', () => {

    it('should return the token stored in session', () => {
      const plugin = new Plugin({})
      const req = {
        params: {
          token: 'myParamToken'
        },
        session: {
          authentication: {
            token: 'myPrevToken',
            expiration: new Date().getTime() + 360000
          }
        }
      }

      plugin.init()

      plugin.migrateRequest = sinon.spy()

      expect(plugin.getExpiringToken(req, {})).to.be.eql('myPrevToken')
    })

    it('should return the token from params', () => {
      const plugin = new Plugin({})
      const req = {
        params: {
          token: 'myParamToken'
        },
        session: {
          authentication: {
            token: 'myPrevToken',
            expiration: new Date().getTime() + 1000
          }
        }
      }

      plugin.init()

      plugin.migrateRequest = sinon.spy()

      expect(plugin.getExpiringToken(req, {})).to.be.eql('myPrevToken')
    })

    it('should return no token if expired session', () => {
      const plugin = new Plugin({})
      const req = {
        session: {
          authentication: {
            token: 'myPrevToken',
            expiration: new Date().getTime() - 1000
          }
        }
      }

      plugin.init()

      plugin.migrateRequest = sinon.spy()

      expect(plugin.getExpiringToken(req, {})).to.be.eql('')
    })
  })

  describe('getRequestToken', () => {

    it('should return the token from the params', () => {
      const plugin = new Plugin({})
      const req = {
        params: {
          token: 'myToken'
        }
      }

      plugin.init()

      expect(plugin.getRequestToken(req)).to.be.eql('myToken')
    })
  })

  describe('getParams', () => {
    it('should return an object', () => {
      const plugin = new Plugin({})

      const result = plugin.getParams()

      expect(result).to.eql({})
    })

    it('should return the params with dynamic variables', () => {
      const plugin = new Plugin({})

      const request = {
        result: {
          dynamic: {
            key: 'dynamic-value'
          }
        }
      }

      const result = plugin.getParams(request)

      expect(result).to.eql({ key: 'dynamic-value' })
    })

    it('should return the params from the query', () => {
      const plugin = new Plugin({})

      const request = {
        params: {
          key: 'param-value'
        }
      }

      const result = plugin.getParams(request)

      expect(result).to.eql({ key: 'param-value' })
    })

    it('should return the params from body', () => {
      const plugin = new Plugin({})

      const request = {
        params: {
          key: 'body-value'
        }
      }

      const result = plugin.getParams(request)

      expect(result).to.eql({ key: 'body-value' })
    })

    it('should give precedence to the url param over dynamic', () => {
      const plugin = new Plugin({})

      const request = {
        result: {
          dynamic: {
            key: 'dynamic-value'
          }
        },
        params: {
          key: 'params-value'
        }
      }

      const result = plugin.getParams(request)

      expect(result).to.eql({ key: 'params-value' })
    })

    it('should give precedence to the params from body', () => {
      const plugin = new Plugin({})

      const request = {
        result: {
          dynamic: {
            key: 'dynamic-value'
          }
        },
        params: {
          key: 'params-value'
        },
        body: {
          key: 'body-value'
        }
      }

      const result = plugin.getParams(request)

      expect(result).to.eql({ key: 'body-value' })
    })

    it('should returned stored token and entitlement information on refresh', () => {
      const plugin = new Plugin({})
      const token = 'myAuthToken'
      const eISBN = 'myeISBN'
      const courseKey = 'myCourseKey'
      const courseCgi = 'myCourseCgi'

      const req = {
        headers: {
          'cengage-sso-refresh': true
        },
        session: {
          headers: {
            'cengage-sso-token': token,
            'cmp-dynamic-eISBN': eISBN,
            'cmp-dynamic-courseKey': courseKey,
            'cmp-dynamic-courseCgi': courseCgi
          },
          sso: {
            token
          },
          params: {
            eISBN,
            courseKey,
            courseCgi
          }
        },
        result: {
          dynamic: {
            key: 'dynamic-value'
          }
        },
        params: {
          key: 'params-value'
        },
        body: {
          key: 'body-value'
        }
      }

      const result = plugin.getParams(req)

      expect(result).to.eql({ key: 'body-value', token, eISBN, courseKey, courseCgi })
    })

    it('should return stored token and entitlement information on proxy target sending refresh header', () => {
      const plugin = new Plugin({})
      const token = 'myAuthToken'
      const eISBN = 'myeISBN'
      const courseKey = 'myCourseKey'
      const courseCgi = 'myCourseCgi'

      const req = {
        headers: {},
        proxyResHeaders: {
          'cengage-sso-refresh': true
        },
        session: {
          headers: {
            'cengage-sso-token': token,
            'cmp-dynamic-eISBN': eISBN,
            'cmp-dynamic-courseKey': courseKey,
            'cmp-dynamic-courseCgi': courseCgi
          },
          sso: {
            token
          },
          params: {
            eISBN,
            courseKey,
            courseCgi
          }
        },
        result: {
          dynamic: {
            key: 'dynamic-value'
          }
        },
        params: {
          key: 'params-value'
        },
        body: {
          key: 'body-value'
        }
      }

      const result = plugin.getParams(req)

      expect(result).to.eql({ key: 'body-value', token, eISBN, courseKey, courseCgi })
    })
  })

  describe('addStatic', () => {
    it('should return an object (proxy) for static', () => {
      const plugin = new Plugin({})
      expect(typeof plugin.addStatic({}).static).to.eql('object')
    })
  })

  describe('getValueFromMappings', () => {

    it('should return values', () => {
      const plugin = new Plugin({})
      const data = {
        data: {
          entitlement: {
            guid: '123',
            role: 'student',
            firstName: '',
            displayName: 'Joe'
          }
        }
      }

      expect(plugin.getValueFromMappings(data, 'static.boopboop')).to.eql('boopboop')
      expect(plugin.getValueFromMappings(data, 'static.boop%20boop')).to.eql('boop boop')
      expect(plugin.getValueFromMappings(data, 'data.entitlement.guid')).to.eql('123')
      expect(plugin.getValueFromMappings(data, 'data.entitlement.role')).to.eql('student')
      expect(plugin.getValueFromMappings(data, 'data.entitlement.firstName|data.entitlement.displayName')).to.eql('Joe')
      expect(plugin.getValueFromMappings(data, 'data.entitlement.firstName|data.entitlement.displayName|data.entitlement.firstName|data.entitlement.displayName|data.entitlement.firstName|data.entitlement.displayName|data.entitlement.firstName|data.entitlement.displayName')).to.eql('Joe')
    })
  })

  describe('hasFallbackPrivilege', () => {

    it('should return the fallback privilege value', () => {
      const plugin = new Plugin({})
      const req = {
        session: {
          fallback: {
            privileged: true
          }
        }
      }

      expect(plugin.hasFallbackPrivilege(req)).to.be.eql(true)
    })

    it('should return the fallback privilege value with namespace', () => {
      const plugin = new Plugin({})
      const req = {
        session: {
          fallback: {
            'my.namespace': {
              privileged: true
            }
          }
        }
      }
      const opts = {
        namespace: 'my.namespace'
      }

      expect(plugin.hasFallbackPrivilege(req, opts)).to.be.eql(true)
    })
  })

  describe('mapFallbackToHeaders', () => {

    it('should map fallback headers from session storage', () => {
      const plugin = new Plugin({})
      const req = {
        session: {
          fallback: {
            token: 'myToken'
          },
          params: {
            courseKey: 'myCourseKey'
          }
        }
      }

      plugin.init()
      plugin.mapFallbackToHeaders(req)

      expect(req.session.headers['cengage-sso-token']).to.be.eql('myToken')
      expect(req.session.headers['cmp-dynamic-courseKey']).to.be.eql('myCourseKey')
    })

    it('should map fallback headers from session storage with namespace defined', () => {
      const plugin = new Plugin({})
      const opts = {
        namespace: 'my.namespace'
      }
      const req = {
        session: {
          fallback: {
            'my.namespace': {
              token: 'myToken'
            }
          },
          params: {
            'my.namespace': {
              courseKey: 'myCourseKey'
            }
          }
        }
      }

      plugin.init()
      plugin.mapFallbackToHeaders(req, opts)

      expect(req.session.headers['cengage-sso-token']).to.be.eql('myToken')
      expect(req.session.headers['cmp-dynamic-courseKey']).to.be.eql('myCourseKey')
    })

    it('should map fallback headers from session storage when namespaced values are set, but no namespace is defined on the request', () => {
      const plugin = new Plugin({})
      const req = {
        session: {
          headers: {},
          fallback: {
            otherToken: 'myOtherToken',
            'my.namespace': {
              token: 'myToken'
            }
          },
          params: {
            param: 'myParam',
            'my.namespace': {
              courseKey: 'myCourseKey'
            }
          }
        }
      }

      plugin.init()
      plugin.mapFallbackToHeaders(req)

      expect(req.session.headers['cengage-sso-token']).to.be.eql(undefined)
      expect(req.session.headers['cmp-dynamic-courseKey']).to.be.eql(undefined)
      expect(req.session.headers['cengage-sso-otherToken']).to.be.eql('myOtherToken')
      expect(req.session.headers['cmp-dynamic-param']).to.be.eql('myParam')
    })
  })

  describe('mapFallbacksToSession', () => {

    it('should map a data structure to session variables', () => {
      const plugin = new Plugin({})
      const req = { session: { params: { courseCgi: 'myCourseCgi' }, fallback: { privileged: true } } }

      const config = {
        transformers: {
          'firstName': 'lower',
          'shouldBeUpperCase': 'upper'
        },
        mappings: {
          requestParams: [ 'courseKey', 'intentionallyMissing', 'shouldBeUpperCase' ],
          authResponse: {
            token: 'token',
            firstName: 'user.firstname',
            lastName: 'user.lastname'
          },
          fallback: {
            cgi: 'legacy.courseCgi',
            firstName: 'user.firstname'
          }
        }
      }

      const sessionData = {
        token: 'myToken',
        user: {
          firstname: 'myFirstNameShouldBeLowerCase',
          lastname: 'myLastName'
        }
      }

      plugin.init()

      plugin.mapFallbacksToSession(req, sessionData, config)

      expect(req.session.fallback.cgi).to.be.eql('myCourseCgi')
      expect(req.session.fallback.firstName).to.be.eql('myfirstnameshouldbelowercase')
    })

    it('should handle when no mappings available', () => {
      const plugin = new Plugin({})
      const req = { session: { fallback: { privileged: true } } }

      const config = {
        transformers: {
          'firstName': 'lower',
          'shouldBeUpperCase': 'upper'
        },
        mappings: {
          fallback: {
            cgi: 'legacy.courseCgi'
          }
        }
      }

      const sessionData = {
        token: 'myToken',
        user: {
          firstname: 'myFirstNameShouldBeLowerCase',
          lastname: 'myLastName'
        }
      }

      plugin.init()

      plugin.defaults.mappings = { authResponse: {}, requestParams: {} }
      plugin.mapFallbacksToSession(req, sessionData, config)

      expect(req.session.fallback).to.be.eql({ privileged: true })
    })

    it('should handle when not privileged', () => {
      const plugin = new Plugin({})
      const req = { session: { fallback: { privileged: false } } }

      const config = {
        transformers: {
          'firstName': 'lower',
          'shouldBeUpperCase': 'upper'
        },
        mappings: {
          fallback: {
            cgi: 'legacy.courseCgi'
          }
        }
      }

      const sessionData = {
        token: 'myToken',
        user: {
          firstname: 'myFirstNameShouldBeLowerCase',
          lastname: 'myLastName'
        }
      }

      plugin.init()

      plugin.defaults.mappings = { authResponse: {}, requestParams: {} }
      plugin.mapFallbacksToSession(req, sessionData, config)

      expect(req.session.fallback).to.be.eql({ privileged: false })
    })
  })

  describe('mapToHeaders', () => {

    it('should map headers from session storage', () => {
      const plugin = new Plugin({})
      const req = {
        session: {
          authentication: {
            token: 'myToken'
          },
          params: {
            courseKey: 'myCourseKey'
          }
        }
      }

      plugin.init()
      plugin.mapToHeaders(req)

      expect(req.session.headers['cengage-sso-token']).to.be.eql('myToken')
      expect(req.session.headers['cmp-dynamic-courseKey']).to.be.eql('myCourseKey')
    })

    it('should map headers from session storage with namespace defined', () => {
      const plugin = new Plugin({})
      const opts = {
        namespace: 'my.namespace'
      }
      const req = {
        session: {
          authentication: {
            'my.namespace': {
              token: 'myToken'
            }
          },
          params: {
            'my.namespace': {
              courseKey: 'myCourseKey'
            }
          }
        }
      }

      plugin.init()
      plugin.mapToHeaders(req, opts)

      expect(req.session.headers['cengage-sso-token']).to.be.eql('myToken')
      expect(req.session.headers['cmp-dynamic-courseKey']).to.be.eql('myCourseKey')
    })

    it('should map headers from session storage when namespaced values are set, but no namespace is defined on the request', () => {
      const plugin = new Plugin({})
      const req = {
        session: {
          headers: {},
          authentication: {
            otherToken: 'myOtherToken',
            'my.namespace': {
              token: 'myToken'
            }
          },
          params: {
            param: 'myParam',
            'my.namespace': {
              courseKey: 'myCourseKey'
            }
          }
        }
      }

      plugin.init()
      plugin.mapToHeaders(req)

      expect(req.session.headers['cengage-sso-token']).to.be.eql(undefined)
      expect(req.session.headers['cmp-dynamic-courseKey']).to.be.eql(undefined)
      expect(req.session.headers['cengage-sso-otherToken']).to.be.eql('myOtherToken')
      expect(req.session.headers['cmp-dynamic-param']).to.be.eql('myParam')
    })
  })

  describe('mapToSession', () => {

    it('should map a data structure to session variables', () => {
      const plugin = new Plugin({})
      const req = { session: { authentication: {} } }

      const config = {
        transformers: {
          'firstName': 'lower',
          'shouldBeUpperCase': 'upper'
        },
        mappings: {
          requestParams: [ 'courseKey', 'intentionallyMissing', 'shouldBeUpperCase' ],
          authResponse: {
            token: 'token',
            firstName: 'user.firstname',
            lastName: 'user.lastname'
          }
        }
      }

      const sessionData = {
        token: 'myToken',
        user: {
          firstname: 'myFirstNameShouldBeLowerCase',
          lastname: 'myLastName'
        }
      }

      plugin.init()

      sinon
        .stub(plugin, 'getParams')
        .returns({
          courseKey: 'myCourseKey',
          shouldBeUpperCase: 'myParamShouldBeUpperCase',
          notNeededKey: 'shouldNotBeMapped'
        })

      plugin.mapToSession(sessionData, req, config)

      expect(req.session.authentication.token).to.be.eql('myToken')
      expect(req.session.authentication.firstName).to.be.eql('myfirstnameshouldbelowercase')
      expect(req.session.authentication.lastName).to.be.eql('myLastName')
      expect(req.session.params.courseKey).to.be.eql('myCourseKey')
      expect(req.session.params.shouldBeUpperCase).to.be.eql('MYPARAMSHOULDBEUPPERCASE')
      expect(req.session.params.notNeededKey).to.be.eql(undefined)
      expect(req.session.params.intentionallyMissing).to.be.eql(undefined)
    })

    it('should handle when no mappings available', () => {
      const plugin = new Plugin({})
      const req = { session: { authentication: {} } }

      const config = {
        transformers: {
          'firstName': 'lower',
          'shouldBeUpperCase': 'upper'
        },
        mappings: {}
      }

      const sessionData = {
        token: 'myToken',
        user: {
          firstname: 'myFirstNameShouldBeLowerCase',
          lastname: 'myLastName'
        }
      }

      plugin.init()

      sinon
        .stub(plugin, 'getParams')
        .returns({
          courseKey: 'myCourseKey',
          shouldBeUpperCase: 'myParamShouldBeUpperCase',
          notNeededKey: 'shouldNotBeMapped'
        })

      plugin.defaults.mappings = { authResponse: {}, requestParams: {} }
      plugin.mapToSession(sessionData, req, config)

      expect(req.session.authentication).to.be.eql({})
    })
  })

  describe('setFallbackPrivilege', () => {

    it('should be true if the user is privileged', () => {
      const plugin = new Plugin({})
      const req = {}
      const data = {
        user: {
          guid: 'a-user'
        }
      }

      const config = {
        privileged: {
          fallback: {
            'user.guid': [ 'a-user' ]
          }
        }
      }

      plugin.setFallbackPrivilege(req, data, config)

      expect(_.get(req, 'session.fallback.privileged')).to.be.true
    })

    it('should be true with namespace if the user is privileged', () => {
      const plugin = new Plugin({})
      const opts = {
        namespace: 'my.namespace'
      }
      const req = {}
      const data = {
        user: {
          guid: 'a-user'
        }
      }

      const config = {
        privileged: {
          fallback: {
            'user.guid': [ 'a-user' ]
          }
        }
      }

      plugin.setFallbackPrivilege(req, data, config, opts)

      expect(_.get(req, 'session.fallback["my.namespace"].privileged')).to.be.true
    })

    it('should be undefined if the user is not privileged', () => {
      const plugin = new Plugin({})
      const req = {}
      const data = {
        user: {
          guid: 'a-user'
        }
      }

      const config = {
        privileged: {
          fallback: {
            'user.guid': [ 'a-different-user' ]
          }
        }
      }

      plugin.setFallbackPrivilege(req, data, config)

      expect(_.get(req, 'session.fallback.privileged')).to.be.undefined
    })
  })

  describe('shouldRefresh', () => {

    it('should return true if invalid number', () => {
      const plugin = new Plugin({})

      expect(plugin.shouldRefresh('abc')).to.be.true
    })

    it('should return true if past ttl', () => {
      const plugin = new Plugin({})

      expect(plugin.shouldRefresh(new Date().getTime(), new Date().getTime())).to.be.true
    })

    it('should return false if not past ttl', () => {
      const plugin = new Plugin({})

      expect(plugin.shouldRefresh(new Date().getTime() - ((3600 * 1000) - 1000), new Date().getTime())).to.be.true
    })
  })

  describe('truncateToken', () => {

    it('should truncate token', () => {
      const plugin = new Plugin({})

      expect(plugin.truncateToken('123456789012345')).to.be.eql('123456789012...')
    })

    it('should handle no token', () => {
      const plugin = new Plugin({})

      expect(plugin.truncateToken()).to.be.eql('...')
    })
  })

  describe('updateAndSaveSession', () => {

    it('should call necessary functions', () => {
      const plugin = new Plugin({})
      const req = {
        preserveSession: sinon.spy()
      }

      const callback = sinon.spy()
      plugin.mapToHeaders = sinon.spy()

      plugin.updateAndSaveSession(req, callback)

      expect(req.preserveSession.calledOnce).to.be.true
    })
  })

  describe('readBody', () => {

    it('should use notAuthenticated if has a bad request', () => {
      const plugin = new Plugin({})
      let req = {}

      plugin.init()

      plugin.notAuthenticated = sinon.spy()

      req.headers = {
        'content-length': 18,
        'content-type': 'application/x-www-form-urlencoded; charset=utf-8'
      }

      plugin.baseConfig = {
        logger: {
          error: sinon.spy(),
          info: sinon.spy()
        }
      }

      plugin.readBody(req, null, null, {})

      expect(plugin.notAuthenticated.calledOnce).to.be.true
      expect(plugin.baseConfig.logger.error.calledOnce).to.be.true

    })

    it('should convert a application/x-www-form-urlencoded body to json', () => {
      const plugin = new Plugin({})
      let req = new Readable()
      const next = () => { }

      plugin.init()

      plugin.notAuthenticated = sinon.spy()
      plugin.handleParams = sinon.spy()

      req.headers = {
        'content-length': 18,
        'content-type': 'application/x-www-form-urlencoded; charset=utf-8'
      }

      plugin.readBody(req, null, next, null)

      req.push('hello=hi&key=value')
      req.push(null)

      setTimeout(() => {
        expect(plugin.notAuthenticated.notCalled).to.be.true
        expect(plugin.handleParams.calledOnce).to.be.true
        expect(req.body.hello).to.be('hi')
        expect(req.body.key).to.be('value')
      }, 1000)
    })
  })



  describe('interceptor', () => {

    it('should return undefined if not configured to run', () => {
      const plugin = new Plugin({})
      plugin.shouldRun = false

      expect(plugin.interceptor()()).to.be.undefined
    })

    it('should process refresh headers', () => {
      const plugin = new Plugin({})
      const headers = {
        'cengage-sso-refresh': true
      }

      sinon.stub(plugin, 'manageSession').callsArg(2)

      plugin.interceptor()({}, {}, headers)
      expect(plugin.manageSession.callCount).to.be.eql(1)
    })

    it('should process logout headers', () => {
      const plugin = new Plugin({})
      const headers = {
        'cengage-sso-logout': true
      }
      const req = {
        preserveSession: sinon.spy()
      }

      plugin.clearHeaders = sinon.spy()
      plugin.clearSession = sinon.spy()

      plugin.interceptor()(req, {}, headers)
      expect(plugin.clearHeaders.callCount).to.be.eql(1)
      expect(plugin.clearSession.callCount).to.be.eql(0)
      expect(req.preserveSession.callCount).to.be.eql(1)
    })

    it('should do nothing with no specific headers headers', () => {
      const plugin = new Plugin({})
      const headers = {}
      const req = {
        preserveSession: sinon.spy()
      }

      plugin.manageSession = sinon.spy()
      plugin.clearSession = sinon.spy()

      plugin.interceptor()(req, {}, headers)
      expect(plugin.manageSession.callCount).to.be.eql(0)
      expect(plugin.clearSession.callCount).to.be.eql(0)
      expect(req.preserveSession.callCount).to.be.eql(0)
    })
  })

  describe('interfaces', () => {

    it('should cover interfaces', () => {
      const plugin = new Plugin({})

      plugin.getClient()
      plugin.fetchAuth()
      plugin.manageSession()
      plugin.resumeSession()

      expect(true).to.be.eql(true)
    })
  })

  describe('middleware', () => {

    it('should return undefined if not configured to run', () => {
      const plugin = new Plugin({})
      plugin.shouldRun = false

      expect(plugin.middleware()({}, {}, function () { return true })).to.be.eql(true)
    })

    it('should readBody if a POST and is readable', () => {
      const plugin = new Plugin({})
      const req = {
        method: 'POST',
        readable: true,
        headers: {
          'content-type': true
        }
      }
      const config = {
        post: true
      }

      plugin.readBody = sinon.spy()

      plugin.middleware()(req, {}, function () { }, config)
      expect(plugin.readBody.callCount).to.be.eql(1)
    })

    it('should NOT readBody if a POST, but req.readable = false and rawBody exists', () => {
      const plugin = new Plugin({})
      const req = {
        method: 'POST',
        readable: false,
        rawBody: true,
        headers: {
          'content-type': true
        }
      }
      const config = {
        post: true
      }

      plugin.readBody = sinon.spy()
      plugin.manageSession = sinon.spy()

      plugin.middleware()(req, {}, function () { }, config)
      expect(plugin.readBody.callCount).to.be.eql(0)
      expect(plugin.manageSession.callCount).to.be.eql(1)
    })

    it('should manageSession if not a POST', () => {
      const plugin = new Plugin({})

      plugin.manageSession = sinon.spy()

      plugin.middleware()({}, {}, function () { }, {})
      expect(plugin.manageSession.callCount).to.be.eql(1)
    })

    it('should set the mode to allow if not defined', () => {
      const plugin = new Plugin({})
      const config = {}

      plugin.manageSession = sinon.spy()

      plugin.middleware()({}, {}, function () { }, config)
      expect(config.mode).to.be.eql('allow')
    })

    it('should not overwrite the mode if defined', () => {
      const plugin = new Plugin({})
      const config = {
        mode: 'restrict'
      }

      plugin.manageSession = sinon.spy()

      plugin.middleware()({}, {}, function () { }, config)
      expect(config.mode).to.be.eql('restrict')
    })
  })
})