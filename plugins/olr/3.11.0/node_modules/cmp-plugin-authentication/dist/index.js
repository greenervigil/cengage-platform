"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const cmp_plugin_base_1 = __importDefault(require("cmp-plugin-base"));
const lodash_1 = __importDefault(require("lodash"));
const LOGOUT_HEADER = 'ciam-session-logout';
const REFRESH_HEADER = 'ciam-session-refresh';
/*
 * Authentication Interface for session plugins
 */
class AuthenticationPlugin extends cmp_plugin_base_1.default {
    constructor(packageFile, options) {
        super(packageFile, options);
    }
    /**
     * Set initial values and settings
     *
     * @public
     * @returns {Promise<void>}
     */
    async init() {
        this.level = 1000;
        this.headerPrefix = this.options.headerPrefix || 'cengage-sso';
        this.authHandlers = {
            'allow': this.handleAuthModeAllow,
            'restrict': this.handleAuthModeRestrict
        };
        this.authModes = Object.keys(this.authHandlers);
        this.defaults = {
            transformers: Object.freeze({
                'role': 'lower'
            }),
            mappings: {
                requestParams: Object.freeze([]),
                authResponse: Object.freeze({})
            }
        };
        this.util = {
            transformFunctions: {
                lower: String.prototype.toLowerCase,
                upper: String.prototype.toUpperCase,
                string: String,
                bool: Boolean
            }
        };
    }
    // eslint-disable-next-line @typescript-eslint/ban-types
    registerMode(mode, handler) {
        this.authHandlers[mode] = handler;
        this.authModes = Object.keys(this.authHandlers);
    }
    /**
     * HEADER/SESSION MANIPULATION
     */
    setHeaderValue(ctx, key, value) {
        ctx.setHeader(`${this.headerPrefix}-${key}`, String(value));
    }
    setParamHeaderValue(ctx, key, value) {
        ctx.setHeader(`cmp-dynamic-${key}`, String(value));
    }
    /**
     * HANDLE MODES
     */
    handleAuthMode(ctx) {
        (this.authHandlers[(this.options.mode || '').toLowerCase()] || function () {
            const { token } = this.getParams(ctx);
            const identity = ctx.session.getIdentity();
            this.logger.warn({
                action: 'bad authentication mode handler',
                value: this.options.mode,
                host: ctx.host,
                token: this.truncateToken(token),
                ssoGuid: identity.guid,
                sessionId: ctx.headers['cmp-session-id']
            });
        }).call(this, ctx);
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    handleAuthModeAllow(ctx) { }
    handleAuthModeRestrict(ctx) {
        ctx.status = 401;
        ctx.selfHandleResponse = true;
        ctx.session.invalidate();
        ctx.body = 'Unauthorized';
    }
    notAuthenticated(ctx) {
        this.handleAuthMode(ctx);
    }
    /**
     * HELPER FUNCTIONS
     */
    getExpiration(ttl = 3600) {
        return Date.now() + ttl * 1000;
    }
    getExpiringToken(ctx) {
        const identity = ctx.session.getIdentity();
        return (this.isAuth(ctx) && this.shouldRefresh(identity.expiration, this.options.ttl)) ? identity.token : '';
    }
    getRequestToken(ctx) {
        return this.getParams(ctx).token;
    }
    // Get the parameters from the query string or body
    getParams(ctx) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const session = ctx.session.get();
        const identity = ctx.session.getIdentity();
        const reqRefreshHeader = ctx.get(REFRESH_HEADER) || ctx.get(`${this.headerPrefix}-refresh`);
        const proxyResRefreshHeader = ((_b = (_a = ctx.proxyRes) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b[REFRESH_HEADER]) || ((_d = (_c = ctx.proxyRes) === null || _c === void 0 ? void 0 : _c.headers) === null || _d === void 0 ? void 0 : _d[`${this.headerPrefix}-refresh`]);
        const noRefreshHeader = !(reqRefreshHeader || proxyResRefreshHeader);
        return lodash_1.default.defaultsDeep({}, ctx.body, ctx.query, 
        // params extracted from route, ie /user/:token, old CMP set this on req.session.result.dynamic
        ctx.params, noRefreshHeader ? {} : {
            token: identity.token,
            eISBN: ((_e = session === null || session === void 0 ? void 0 : session.params) === null || _e === void 0 ? void 0 : _e.eISBN) || '',
            courseKey: ((_f = session === null || session === void 0 ? void 0 : session.params) === null || _f === void 0 ? void 0 : _f.courseKey) || '',
            courseKeyType: ((_g = session === null || session === void 0 ? void 0 : session.params) === null || _g === void 0 ? void 0 : _g.courseKeyType) || '',
            courseCgi: ((_h = session === null || session === void 0 ? void 0 : session.params) === null || _h === void 0 ? void 0 : _h.courseCgi) || ''
        });
    }
    addStatic(collection) {
        const collectionWithStatic = Object.assign(collection || {}, {
            static: new Proxy({}, {
                get: (target, name) => {
                    try {
                        return decodeURI(name.toString());
                    }
                    catch (e) {
                        this.logger.error({
                            action: 'retrieve static mapping value',
                            error: e
                        });
                    }
                }
            })
        });
        return collectionWithStatic;
    }
    getValueFromMappings(collection, keys) {
        const keysReduced = lodash_1.default(keys).split('|').reduce((acc, key) => {
            return acc ? acc : lodash_1.default.get(this.addStatic(collection), key, '');
        }, '');
        return keysReduced;
    }
    isAuth(ctx) {
        const identity = ctx.session.getIdentity();
        return identity.token && (identity.expiration > Date.now());
    }
    hasFallbackPrivilege(ctx) {
        var _a, _b;
        const fullSession = ctx.session.getSessionData();
        return ((_b = (_a = fullSession === null || fullSession === void 0 ? void 0 : fullSession.sso) === null || _a === void 0 ? void 0 : _a.fallback) === null || _b === void 0 ? void 0 : _b.privileged) || false;
    }
    mapFallbacksToHeaders(ctx) {
        const ssoValues = Object.assign({}, ctx.session.getSessionData().sso || {});
        const session = ctx.session.get();
        Object.keys(ssoValues.fallback || {}).forEach(key => {
            const val = ssoValues.fallback[key] || '';
            if (!lodash_1.default.isObject(val) && lodash_1.default.isUndefined(lodash_1.default.get(session, `mappings[${key}]`))) {
                this.setHeaderValue(ctx, key, val);
            }
        });
        Object.keys(ssoValues.params || {}).forEach(key => {
            const val = ssoValues.params[key] || '';
            if (!lodash_1.default.isObject(val) && lodash_1.default.isUndefined(lodash_1.default.get(session, `params[${key}]`))) {
                this.setParamHeaderValue(ctx, key, val);
            }
        });
    }
    mapFallbacksToSession(ctx, sessionData) {
        const params = this.getParams(ctx);
        const fallbackMappings = lodash_1.default.get(this.options, 'mappings.fallback', {});
        const transformers = lodash_1.default.get(this.options, 'transformers', this.defaults.transformers);
        const privileged = this.hasFallbackPrivilege(ctx);
        const finalValues = {
            fallback: {
                privileged
            }
        };
        if (fallbackMappings && privileged) {
            Object.keys(fallbackMappings).forEach(key => {
                let mappedValue = '';
                if (lodash_1.default.startsWith(fallbackMappings[key], 'legacy.')) {
                    mappedValue = this.getValueFromMappings(params, fallbackMappings[key].substr(7));
                }
                else {
                    mappedValue = this.getValueFromMappings(sessionData, fallbackMappings[key]);
                }
                const value = !!transformers[key] && !!this.util.transformFunctions[transformers[key]] ? this.util.transformFunctions[transformers[key]].call(mappedValue) : mappedValue;
                if (value) {
                    finalValues.fallback[key] = value;
                }
            });
        }
        return finalValues;
    }
    mapToHeaders(ctx) {
        const cachedValues = ctx.session.get();
        Object.keys(cachedValues.mapped || {}).forEach(key => {
            const val = cachedValues.mapped[key] || '';
            if (!lodash_1.default.isObject(val)) {
                this.setHeaderValue(ctx, key, val);
            }
        });
        Object.keys(cachedValues.params || {}).forEach(key => {
            const val = cachedValues.params[key] || '';
            if (!lodash_1.default.isObject(val)) {
                this.setParamHeaderValue(ctx, key, val);
            }
        });
    }
    mapToSession(ctx, sessionData) {
        const params = this.getParams(ctx);
        const transformers = lodash_1.default.get(this.options, 'transformers', this.defaults.transformers);
        const authResponseMappings = lodash_1.default.get(this.options, 'mappings.authResponse', this.defaults.mappings.authResponse);
        const requestParamsMappings = lodash_1.default.get(this.options, 'mappings.requestParams', this.defaults.mappings.requestParams);
        const finalValues = {
            mapped: {},
            params: {}
        };
        Object.keys(authResponseMappings).forEach((key) => {
            const mappedValue = this.getValueFromMappings(sessionData, authResponseMappings[key]);
            const value = !!transformers[key] && !!this.util.transformFunctions[transformers[key]] ? this.util.transformFunctions[transformers[key]].call(mappedValue) : mappedValue;
            finalValues.mapped[key] = value;
        });
        if (requestParamsMappings.length) {
            requestParamsMappings.forEach((key) => {
                if (params[key]) {
                    const mappedValue = this.getValueFromMappings(params, key);
                    const value = !!transformers[key] && !!this.util.transformFunctions[transformers[key]] ? this.util.transformFunctions[transformers[key]].call(mappedValue) : mappedValue;
                    finalValues.params[key] = value;
                }
            });
        }
        return finalValues;
    }
    setFallbackPrivilege(ctx, data) {
        const session = ctx.session.get();
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        const privileged = lodash_1.default.reduce(lodash_1.default.get(this.options, 'privileged.fallback', []), (acc, value, key) => {
            return acc || Boolean(~value.indexOf(lodash_1.default.get(data, key)));
        }, false);
        if (privileged) {
            lodash_1.default.set(session, 'fallback.privileged', true);
            ctx.session.set(session);
        }
    }
    shouldRefresh(expiration, ttl = 3600) {
        if (isNaN(Number(expiration))) {
            return true;
        }
        else {
            return (expiration - Date.now()) < (ttl * 1000 * 0.2);
        }
    }
    truncateToken(token = '') {
        return token.substr(0, 12) + '...';
    }
    /**
     * Function to be ran after the proxy target responds
     * This function cannot modify the response and is intended for asynchronous work
     *
     * @public
     * @param {cmpContext} - ctx
     * @returns {Promise<void>}
     */
    async interceptor(ctx) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (((_b = (_a = ctx.proxyRes) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b[REFRESH_HEADER]) || ((_d = (_c = ctx.proxyRes) === null || _c === void 0 ? void 0 : _c.headers) === null || _d === void 0 ? void 0 : _d[`${this.headerPrefix}-refresh`])) {
            return this.manageSession(ctx);
        }
        else if (((_f = (_e = ctx.proxyRes) === null || _e === void 0 ? void 0 : _e.headers) === null || _f === void 0 ? void 0 : _f[LOGOUT_HEADER]) || ((_h = (_g = ctx.proxyRes) === null || _g === void 0 ? void 0 : _g.headers) === null || _h === void 0 ? void 0 : _h[`${this.headerPrefix}-logout`])) {
            ctx.session.logout();
        }
    }
    /**
     * Function to be ran during request prior to hitting the proxy target
     *
     * @public
     * @param {cmpContext} - ctx
     * @returns {Promise<void>}
     */
    async middleware(ctx) {
        this.options.mode = (this.options.mode) ? this.options.mode : 'allow';
        return this.manageSession(ctx);
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    async manageSession(ctx) { }
}
exports.default = AuthenticationPlugin;
