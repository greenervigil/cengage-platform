const expect = require('chai').expect
const http   = require('http')
const Readable = require('stream').Readable
const sinon  = require('sinon')
const Plugin = require('../index')

describe('CMP Plugin: OLR', () => {

  describe('init', () => {

    it('should init with default property values set', () => {
      const plugin = new Plugin({})

      plugin.registerMode = sinon.spy()
      plugin.init()

      const expectedRequestParamsMappings = [
        'eISBN', 'titleIsbn', 'courseKey', 'ctx', 'ILRN_CODE', 'courseCgi'
      ]

      const expectedAuthResponseMappings = {
        'guid': 'data.entitlement.guid',
        'role': 'entitlementProduct.enrollmentType',
        'cgi': 'entitlementProduct.cgi',
        'institution': 'data.entitlement.institutionName',
        'institution-id': 'data.entitlement.cnowInstitutionId'
      }

      expect(plugin.clients.length).to.be.eql(0)
      expect(plugin.defaults.mappings.requestParams).to.be.eql(expectedRequestParamsMappings)
      expect(plugin.defaults.mappings.authResponse).to.be.eql(expectedAuthResponseMappings)
    })
  })

  describe('trends', () => {

    it('should resolve trends data', () => {
      const plugin = new Plugin({})
      const req = {
        header: sinon.spy(),
        fetchHandlerTime: sinon.spy()
      }
      const res = {}
      const config = {}

      let resolver = null
      const p1 = new Promise((resolve) => {
        resolver = resolve
      })

      p1.then((data) => {
        expect(data).to.not.be.undefined
      })

      plugin.trends(config)(req, res, resolver)      
    })
  })

  describe('getClient', () => {

    it('should return undefined if there is no endpoint in the config', () => {
      const plugin = new Plugin({})
      const config = {}

      const client = plugin.getClient(config)

      expect(client).to.be.undefined
    })

    it('should cache the client when a new one is created', () => {
      const plugin = new Plugin({})
      const config = {
        endpoint: 'http://endpoint'
      }

      const client = plugin.getClient(config)

      expect(client).to.eql(plugin.clients[config.endpoint])
    })

    it('should use return the client from the cache', () => {
      const plugin = new Plugin({})
      const fakeClient = 'fake client in cache'
      const config = {
        endpoint: 'http://endpoint'
      }

      plugin.clients[config.endpoint] = fakeClient
      const client = plugin.getClient(config)

      expect(client).to.eql(fakeClient)
    })
  })

  describe('handleAuthModeRestrict', () => {
    const plugin = new Plugin({})
    const config = {}
    const req = {}

    const endSpy = sinon.spy()
    const res = {
      status: () => {
        return {
          end: endSpy
        }
      }
    }

    plugin.handleAuthModeRestrict(req, res, function() {}, {})

    expect(endSpy.callCount).to.be.eql(1)
  })

  describe('handleAuthError', () => {

    it('should process fallback if privileges process unauthenticated', () => {
      const plugin = new Plugin({})
      const config = {}
      const req = {
        endHandlerTimer: sinon.spy(),
        header: sinon.spy()
      }

      plugin.baseConfig = {
        logger: {
          error: sinon.spy()
        }
      }
      plugin.notAuthenticated = sinon.spy()
      plugin.mapToSession = sinon.spy()
      plugin.mapFallbacksToSession = sinon.spy()
      plugin.mapFallbackToHeaders = sinon.spy()
      plugin.updateAndSaveSession = sinon.spy()

      sinon
        .stub(plugin, 'hasFallbackPrivilege')
        .returns(true)

      plugin.handleAuthError('token', {}, {}, req, function() {}, {})

      expect(req.endHandlerTimer.callCount).to.be.eql(1)
      expect(plugin.mapToSession.callCount).to.be.eql(1)
      expect(plugin.mapFallbacksToSession.callCount).to.be.eql(1)
      expect(plugin.mapFallbackToHeaders.callCount).to.be.eql(1)
      expect(plugin.updateAndSaveSession.callCount).to.be.eql(1)
      expect(plugin.baseConfig.logger.error.callCount).to.be.eql(0)
      expect(plugin.notAuthenticated.callCount).to.be.eql(0)
      expect(req.header.callCount).to.eql(0)
    })

    it('should log the error and throw 401', () => {
      const plugin = new Plugin({})
      const config = {}
      const req = {
        endHandlerTimer: sinon.spy(),
        header: sinon.spy()
      }

      plugin.notAuthenticated = sinon.spy()

      plugin.baseConfig = {
        logger: {
          error: sinon.spy()
        }
      }

      plugin.handleAuthError('token', {}, {}, req, function() {}, {})

      expect(req.endHandlerTimer.callCount).to.eql(1)
      expect(plugin.baseConfig.logger.error.callCount).to.be.eql(1)
      expect(plugin.notAuthenticated.callCount).to.be.eql(1)
      expect(req.header.callCount).to.eql(1)
    })

    it('should log the error and process unauthenticated with namespace defined', () => {
      const plugin = new Plugin({})
      const config = {}
      const req = {
        endHandlerTimer: sinon.spy(),
        header: sinon.spy()
      }

      plugin.notAuthenticated = sinon.spy()

      plugin.baseConfig = {
        logger: {
          error: sinon.spy()
        }
      }

      plugin.handleAuthError('token', { courseCgi: 'myCourseCgi' }, {}, req, function() {}, {})

      expect(req.endHandlerTimer.callCount).to.eql(1)
      expect(plugin.baseConfig.logger.error.callCount).to.be.eql(1)
      expect(plugin.notAuthenticated.callCount).to.be.eql(1)
      expect(req.header.callCount).to.eql(1)
    })
  })

  describe('fetchAuth', () => {

    it('should pass on to the correct handler if given an eISBN param', () => {
      const plugin = new Plugin({})
      const mockClient = {
        getEntitlements: sinon.spy(),
        getAllEntitlements: sinon.spy()
      }

      sinon
        .stub(plugin, 'getClient')
        .returns(mockClient)

      plugin.fetchAuth('token', { eISBN: true }, function() {})

      expect(plugin.getClient.callCount).to.be.eql(1)
      expect(mockClient.getEntitlements.callCount).to.be.eql(1)
      expect(mockClient.getAllEntitlements.callCount).to.be.eql(0)
    })

    it('should pass on to the correct handler if not given an eISBN param', () => {
      const plugin = new Plugin({})
      const mockClient = {
        getEntitlements: sinon.spy(),
        getAllEntitlements: sinon.spy()
      }

      sinon
        .stub(plugin, 'getClient')
        .returns(mockClient)

      plugin.fetchAuth('token', {}, function() {})

      expect(plugin.getClient.callCount).to.be.eql(1)
      expect(mockClient.getEntitlements.callCount).to.be.eql(0)
      expect(mockClient.getAllEntitlements.callCount).to.be.eql(1)
    })
  })

  describe('getEntitlementProductFromAll', () => {

    it('should return undefined if unable to find an entitlement with the given params', () => {
      const plugin = new Plugin({})
      const courseKey = 'myCourseKey'
      const courseCgi = 'myCourseCgi'
      const config = {}

      const entitlementProduct = {
        contextId: 'notMyKey',
        cgi: 'notMyCgi'
      }

      const data = {
        entitlement: {
          titles: {
            title: [ {
              products: {
                entitlementProduct: [ entitlementProduct ]
              }
            } ]
          }
        }
      }

      const ret = plugin.getEntitlementProductFromAll({ data, courseKey, courseCgi, config })
      expect(ret).to.be.eql(undefined)
    })

    it('should return an entitlement if found by courseKey', () => {
      const plugin = new Plugin({})
      const courseKey = 'myCourseKey'
      const courseCgi = 'myCourseCgi'
      const config = {}

      const entitlementProduct = {
        contextId: 'myCourseKey',
        cgi: ''
      }

      const data = {
        entitlement: {
          titles: {
            title: [ {
              products: {
                entitlementProduct: [ entitlementProduct ]
              }
            } ]
          }
        }
      }

      const ret = plugin.getEntitlementProductFromAll({ data, courseKey, courseCgi, config })
      expect(ret).to.be.eql(entitlementProduct)
    })

    it('should return an entitlement if found by courseCgi', () => {
      const plugin = new Plugin({})
      const courseKey = 'myCourseKey'
      const courseCgi = 'myCourseCgi'
      const config = {}

      const entitlementProduct = {
        contextId: '',
        cgi: 'myCourseCgi'
      }

      const data = {
        entitlement: {
          titles: {
            title: [ {
              products: {
                entitlementProduct: [ entitlementProduct ]
              }
            } ]
          }
        }
      }

      const ret = plugin.getEntitlementProductFromAll({ data, courseKey, courseCgi, config })
      expect(ret).to.be.eql(entitlementProduct)
    })
  })

  describe('getEntitlementProduct', () => {

    it('should return undefined if no titles', () => {
      const plugin = new Plugin({})
      const courseKey = 'myCourseKey'
      const data = {
        entitlement: {
          titles: {

          }
        }
      }

      expect(plugin.getEntitlementProduct({ data, courseKey })).to.eql(undefined)
    })

    it('should return from courseKey on first title', () => {
      const plugin = new Plugin({})
      const courseKey = 'myCourseKey'
      const data = {
        entitlement: {
          titles: {
            title: [ {
              products: {
                entitlementProduct: [ {
                  id: 0,
                  contextId: courseKey
                }, {
                  id: 1,
                  contextId: courseKey + '_other'
                } ]
              }
            } ]
          }
        }
      }

      expect(plugin.getEntitlementProduct({ data, courseKey }).id).to.eql(0)
    })

    it('should return from courseKey on secondary titles', () => {
      const plugin = new Plugin({})
      const courseKey = 'myCourseKey'
      const data = {
        entitlement: {
          titles: {
            title: [ {
              products: {
                entitlementProduct: [ {
                  id: 0,
                  contextId: courseKey + '_other'
                }, {
                  id: 1,
                  contextId: courseKey
                } ]
              }
            } ]
          }
        }
      }

      expect(plugin.getEntitlementProduct({ data, courseKey }).id).to.eql(1)
    })

    it('should return from courseCgi on first title', () => {
      const plugin = new Plugin({})
      const courseCgi = 'myCourseCgi'
      const data = {
        entitlement: {
          titles: {
            title: [ {
              products: {
                entitlementProduct: [ {
                  id: 0,
                  cgi: courseCgi
                }, {
                  id: 1,
                  cgi: courseCgi + '_other'
                } ]
              }
            } ]
          }
        }
      }

      expect(plugin.getEntitlementProduct({ data, courseCgi }).id).to.eql(0)
    })

    it('should return from courseCgi on secondary titles', () => {
      const plugin = new Plugin({})
      const courseCgi = 'myCourseCgi'
      const data = {
        entitlement: {
          titles: {
            title: [ {
              products: {
                entitlementProduct: [ {
                  id: 0,
                  cgi: courseCgi + '_other'
                }, {
                  id: 1,
                  cgi: courseCgi
                } ]
              }
            } ]
          }
        }
      }

      expect(plugin.getEntitlementProduct({ data, courseCgi }).id).to.eql(1)
    })

    it('should return false if unable to find from given courseKey or courseCgi', () => {
      const plugin = new Plugin({})
      const courseCgi = ''
      const data = {
        entitlement: {
          titles: {
            title: [ {
              products: {
                entitlementProduct: [ {
                  id: 0,
                  cgi: courseCgi + '_other'
                }, {
                  id: 1,
                  cgi: courseCgi + '_another'
                } ]
              }
            } ]
          }
        }
      }

      expect(plugin.getEntitlementProduct({ data, courseCgi })).to.eql(false)
    })
  })

  describe('handleAuthSuccess', () => {

    it('should call getEntitlementProduct if given an eISBN', () => {
      const plugin = new Plugin({})
      const callback = sinon.spy()
      plugin.getEntitlementProduct = sinon.spy()
      plugin.getEntitlementProductFromAll = sinon.spy()

      plugin.handleAuthSuccess({}, { eISBN: true }, {}, callback)

      expect(plugin.getEntitlementProduct.callCount).to.be.eql(1)
      expect(plugin.getEntitlementProductFromAll.callCount).to.be.eql(0)
    })

    it('should call getAllEntitlements if not given an eISBN', () => {
      const plugin = new Plugin({})
      const callback = sinon.spy()
      plugin.getEntitlementProduct = sinon.spy()
      plugin.getEntitlementProductFromAll = sinon.spy()

      plugin.handleAuthSuccess({}, {}, {}, callback)

      expect(plugin.getEntitlementProduct.callCount).to.be.eql(0)
      expect(plugin.getEntitlementProductFromAll.callCount).to.be.eql(1)
    })
  })

  describe('manageSession', () => {

    it('should fetchAuth if a token is set, and a courseKey is given, then handle errors', () => {
      const plugin = new Plugin({})
      const err = true
      const req = {
        header: () => { return 'localhost' },
        startHandlerTimer: sinon.spy()
      }
      const authData = {
        resultCode: 401
      }

      sinon.stub(plugin, 'getParams').returns({ courseKey: true, token: 'myToken' })
      sinon.stub(plugin, 'fetchAuth').callsArgWith(3, err, authData)
      sinon.stub(plugin, 'shouldRefresh').returns(false)

      plugin.clearSession = sinon.spy()
      plugin.sanitizeUnauthorizedEntitlements = sinon.spy()
      plugin.handleAuthError = sinon.spy()
      plugin.mapToSession = sinon.spy()

      plugin.manageSession(req)

      expect(req.startHandlerTimer.callCount).to.be.eql(1)
      expect(plugin.clearSession.callCount).to.be.eql(0)
      expect(plugin.sanitizeUnauthorizedEntitlements.callCount).to.be.eql(0)
      expect(plugin.handleAuthError.callCount).to.be.eql(1)
      expect(plugin.mapToSession.callCount).to.be.eql(0)
    })

    it('should fetchAuth if given a token, courseKey and eISBN, and handle success', () => {
      const plugin = new Plugin({})
      const err = false
      const req = {
        header: () => { return 'localhost' },
        startHandlerTimer: sinon.spy(),
        endHandlerTimer: sinon.spy()
      }
      const authData = {
        resultCode: 0
      }
      const processedData = {
        title: true
      }

      sinon.stub(plugin, 'getParams').returns({ courseKey: true, eISBN: true, token: 'myToken' })
      sinon.stub(plugin, 'fetchAuth').callsArgWith(3, err, authData)
      sinon.stub(plugin, 'handleAuthSuccess').callsArgWith(3, processedData)
      sinon.stub(plugin, 'shouldRefresh').returns(false)

      plugin.clearSession = sinon.spy()
      plugin.sanitizeUnauthorizedEntitlements = sinon.spy()
      plugin.handleAuthError = sinon.spy()
      plugin.mapToSession = sinon.spy()
      plugin.setSessionValue = sinon.spy()
      plugin.updateAndSaveSession = sinon.spy()

      plugin.manageSession(req, {}, function() {}, {})

      expect(req.startHandlerTimer.callCount).to.be.eql(1)
      expect(plugin.clearSession.callCount).to.be.eql(1)
      expect(plugin.sanitizeUnauthorizedEntitlements.callCount).to.be.eql(1)
      expect(plugin.handleAuthError.callCount).to.be.eql(0)
      expect(plugin.mapToSession.callCount).to.be.eql(1)
      expect(plugin.setSessionValue.callCount).to.be.eql(3)
      expect(plugin.updateAndSaveSession.callCount).to.be.eql(1)
      expect(req.endHandlerTimer.callCount).to.be.eql(1)
    })

    it('should fetchAuth if given a token and courseKey, and handle success', () => {
      const plugin = new Plugin({})
      const err = false
      const req = {
        header: () => { return 'localhost' },
        startHandlerTimer: sinon.spy(),
        endHandlerTimer: sinon.spy()
      }
      const authData = {
        resultCode: 0
      }
      const processedData = {

      }

      sinon.stub(plugin, 'getParams').returns({ courseKey: true, token: 'myToken' })
      sinon.stub(plugin, 'fetchAuth').callsArgWith(3, err, authData)
      sinon.stub(plugin, 'handleAuthSuccess').callsArgWith(3, processedData)
      sinon.stub(plugin, 'shouldRefresh').returns(false)

      plugin.clearSession = sinon.spy()
      plugin.sanitizeUnauthorizedEntitlements = sinon.spy()
      plugin.handleAuthError = sinon.spy()
      plugin.mapToSession = sinon.spy()
      plugin.setSessionValue = sinon.spy()
      plugin.updateAndSaveSession = sinon.spy()

      plugin.manageSession(req, {}, function() {}, {})

      expect(req.startHandlerTimer.callCount).to.be.eql(1)
      expect(plugin.clearSession.callCount).to.be.eql(1)
      expect(plugin.sanitizeUnauthorizedEntitlements.callCount).to.be.eql(1)
      expect(plugin.handleAuthError.callCount).to.be.eql(0)
      expect(plugin.mapToSession.callCount).to.be.eql(1)
      expect(plugin.setSessionValue.callCount).to.be.eql(3)
      expect(plugin.updateAndSaveSession.callCount).to.be.eql(1)
      expect(req.endHandlerTimer.callCount).to.be.eql(1)
    })

    it('should fetchAuth if given a token and courseKey, and handle success with no processed data', () => {
      const plugin = new Plugin({})
      const err = false
      const req = {
        header: () => { return 'localhost' },
        startHandlerTimer: sinon.spy(),
        endHandlerTimer: sinon.spy()
      }
      const authData = {
        resultCode: 0
      }
      const processedData = false

      sinon.stub(plugin, 'getParams').returns({ courseKey: true, token: 'myToken' })
      sinon.stub(plugin, 'fetchAuth').callsArgWith(3, err, authData)
      sinon.stub(plugin, 'handleAuthSuccess').callsArgWith(3, processedData)
      sinon.stub(plugin, 'shouldRefresh').returns(false)

      plugin.clearSession = sinon.spy()
      plugin.sanitizeUnauthorizedEntitlements = sinon.spy()
      plugin.handleAuthError = sinon.spy()
      plugin.mapToSession = sinon.spy()
      plugin.setSessionValue = sinon.spy()
      plugin.setFallbackData = sinon.spy()
      plugin.updateAndSaveSession = sinon.spy()

      plugin.manageSession(req, {}, function() {}, {})

      expect(req.startHandlerTimer.callCount).to.be.eql(1)
      expect(plugin.clearSession.callCount).to.be.eql(0)
      expect(plugin.sanitizeUnauthorizedEntitlements.callCount).to.be.eql(0)
      expect(plugin.handleAuthError.callCount).to.be.eql(0)
      expect(plugin.mapToSession.callCount).to.be.eql(0)
      expect(plugin.setSessionValue.callCount).to.be.eql(0)
      expect(plugin.setFallbackData.callCount).to.be.eql(1)
      expect(plugin.updateAndSaveSession.callCount).to.be.eql(1)
      expect(req.endHandlerTimer.callCount).to.be.eql(1)
    })

    it('should fetchAuth if given a token and courseCgi, and handle success', () => {
      const plugin = new Plugin({})
      const err = false
      const req = {
        header: () => { return 'localhost' },
        startHandlerTimer: sinon.spy(),
        endHandlerTimer: sinon.spy()
      }
      const authData = {
        resultCode: 0
      }
      const processedData = {

      }

      sinon.stub(plugin, 'getParams').returns({ courseCgi: true, token: 'myToken' })
      sinon.stub(plugin, 'fetchAuth').callsArgWith(3, err, authData)
      sinon.stub(plugin, 'handleAuthSuccess').callsArgWith(3, processedData)
      sinon.stub(plugin, 'shouldRefresh').returns(false)

      plugin.clearSession = sinon.spy()
      plugin.sanitizeUnauthorizedEntitlements = sinon.spy()
      plugin.handleAuthError = sinon.spy()
      plugin.mapToSession = sinon.spy()
      plugin.setSessionValue = sinon.spy()
      plugin.updateAndSaveSession = sinon.spy()

      plugin.manageSession(req, {}, function() {}, {})

      expect(req.startHandlerTimer.callCount).to.be.eql(1)
      expect(plugin.clearSession.callCount).to.be.eql(1)
      expect(plugin.sanitizeUnauthorizedEntitlements.callCount).to.be.eql(1)
      expect(plugin.handleAuthError.callCount).to.be.eql(0)
      expect(plugin.mapToSession.callCount).to.be.eql(1)
      expect(plugin.setSessionValue.callCount).to.be.eql(3)
      expect(plugin.updateAndSaveSession.callCount).to.be.eql(1)
      expect(req.endHandlerTimer.callCount).to.be.eql(1)
    })

    it('should fetchAuth if given a token and courseCgi, and handle success with no processed data', () => {
      const plugin = new Plugin({})
      const err = false
      const req = {
        header: () => { return 'localhost' },
        startHandlerTimer: sinon.spy(),
        endHandlerTimer: sinon.spy()
      }
      const authData = {
        resultCode: 0
      }
      const processedData = false
      const next = sinon.spy()

      sinon.stub(plugin, 'getParams').returns({ courseCgi: true, token: 'myToken' })
      sinon.stub(plugin, 'fetchAuth').callsArgWith(3, err, authData)
      sinon.stub(plugin, 'handleAuthSuccess').callsArgWith(3, processedData)
      sinon.stub(plugin, 'shouldRefresh').returns(false)

      plugin.clearSession = sinon.spy()
      plugin.sanitizeUnauthorizedEntitlements = sinon.spy()
      plugin.handleAuthError = sinon.spy()
      plugin.mapToSession = sinon.spy()
      plugin.setSessionValue = sinon.spy()
      plugin.updateAndSaveSession = sinon.spy()
      plugin.setFallbackData = sinon.spy()

      plugin.manageSession(req, {}, next, {})

      expect(req.startHandlerTimer.callCount).to.be.eql(1)
      expect(plugin.clearSession.callCount).to.be.eql(0)
      expect(plugin.sanitizeUnauthorizedEntitlements.callCount).to.be.eql(0)
      expect(plugin.handleAuthError.callCount).to.be.eql(0)
      expect(plugin.mapToSession.callCount).to.be.eql(0)
      expect(plugin.setSessionValue.callCount).to.be.eql(0)
      expect(plugin.setFallbackData.callCount).to.be.eql(1)
      expect(plugin.updateAndSaveSession.callCount).to.be.eql(1)
      expect(req.endHandlerTimer.callCount).to.be.eql(1)
    })

    it('should fetchAuth if a token is set, no courseKey, but an eISBN is given, then handle errors', () => {
      const plugin = new Plugin({})
      const err = true
      const req = {
        header: () => { return 'localhost' },
        startHandlerTimer: sinon.spy()
      }
      const authData = {
        resultCode: 401
      }

      sinon.stub(plugin, 'getParams').returns({ eISBN: 'myEISBN', token: 'myToken' })
      sinon.stub(plugin, 'fetchAuth').callsArgWith(3, err, authData)
      sinon.stub(plugin, 'shouldRefresh').returns(false)

      plugin.clearSession = sinon.spy()
      plugin.sanitizeUnauthorizedEntitlements = sinon.spy()
      plugin.handleAuthError = sinon.spy()
      plugin.mapToSession = sinon.spy()

      plugin.manageSession(req)

      expect(req.startHandlerTimer.callCount).to.be.eql(1)
      expect(plugin.clearSession.callCount).to.be.eql(0)
      expect(plugin.sanitizeUnauthorizedEntitlements.callCount).to.be.eql(0)
      expect(plugin.handleAuthError.callCount).to.be.eql(1)
      expect(plugin.mapToSession.callCount).to.be.eql(0)
    })

    it('should fetchAuth if given a token and eISBN, but no courseKey/courseCgi, and handle success', () => {
      const plugin = new Plugin({})
      const err = false
      const req = {
        header: () => { return 'localhost' },
        startHandlerTimer: sinon.spy(),
        endHandlerTimer: sinon.spy()
      }
      const authData = {
        resultCode: 0
      }
      const processedData = {

      }

      sinon.stub(plugin, 'getParams').returns({ eISBN: 'myEISBN', token: 'myToken' })
      sinon.stub(plugin, 'fetchAuth').callsArgWith(3, err, authData)
      sinon.stub(plugin, 'shouldRefresh').returns(false)

      plugin.clearSession = sinon.spy()
      plugin.sanitizeUnauthorizedEntitlements = sinon.spy()
      plugin.handleAuthError = sinon.spy()
      plugin.mapToSession = sinon.spy()
      plugin.setSessionValue = sinon.spy()
      plugin.updateAndSaveSession = sinon.spy()

      plugin.manageSession(req, {}, function() {}, {})

      expect(req.startHandlerTimer.callCount).to.be.eql(1)
      expect(plugin.clearSession.callCount).to.be.eql(1)
      expect(plugin.sanitizeUnauthorizedEntitlements.callCount).to.be.eql(1)
      expect(plugin.handleAuthError.callCount).to.be.eql(0)
      expect(plugin.mapToSession.callCount).to.be.eql(1)
      expect(plugin.setSessionValue.callCount).to.be.eql(3)
      expect(plugin.updateAndSaveSession.callCount).to.be.eql(1)
      expect(req.endHandlerTimer.callCount).to.be.eql(1)
    })

    it('should fetchAuth if no params but the current entitlement is expiring', () => {
      const plugin = new Plugin({})
      const err = false
      const req = {
        params: {},
        header: () => { return 'localhost' },
        startHandlerTimer: sinon.spy(),
        endHandlerTimer: sinon.spy(),
        session: {
          params: {
            'key:true': {
              courseKey: true
            }
          },
          mappings: {
            localhost: {
              currentEntitlement: 'key:true'
            }
          },
          sso: {
            token: 'myToken',
            expiration: 1234
          }
        }
      }
      const authData = {
        resultCode: 0
      }
      const processedData = {
        title: true
      }

      sinon.stub(plugin, 'getParams').returns({ courseKey: true, eISBN: true, token: 'myToken' })
      sinon.stub(plugin, 'fetchAuth').callsArgWith(3, err, authData)
      sinon.stub(plugin, 'handleAuthSuccess').callsArgWith(3, processedData)
      sinon.stub(plugin, 'shouldRefresh').returns(true)

      plugin.clearSession = sinon.spy()
      plugin.sanitizeUnauthorizedEntitlements = sinon.spy()
      plugin.handleAuthError = sinon.spy()
      plugin.mapToSession = sinon.spy()
      plugin.setSessionValue = sinon.spy()
      plugin.updateAndSaveSession = sinon.spy()
      plugin.getExpiration = sinon.spy()

      plugin.manageSession(req, {}, function() {}, {})

      expect(req.startHandlerTimer.callCount).to.be.eql(1)
      expect(plugin.clearSession.callCount).to.be.eql(1)
      expect(plugin.sanitizeUnauthorizedEntitlements.callCount).to.be.eql(1)
      expect(plugin.handleAuthError.callCount).to.be.eql(0)
      expect(plugin.mapToSession.callCount).to.be.eql(1)
      expect(plugin.setSessionValue.callCount).to.be.eql(3)
      expect(plugin.updateAndSaveSession.callCount).to.be.eql(1)
      expect(req.endHandlerTimer.callCount).to.be.eql(1)
      expect(plugin.getExpiration.callCount).to.be.eql(0)
    })

    it('should fetchAuth if no params but the current entitlement is expiring and only eISBN saved', () => {
      const plugin = new Plugin({})
      const err = false
      const req = {
        params: {},
        header: () => { return 'localhost' },
        startHandlerTimer: sinon.spy(),
        endHandlerTimer: sinon.spy(),
        session: {
          params: {
            'key:undefined': {
              eISBN: true
            }
          },
          mappings: {
            localhost: {
              currentEntitlement: 'key:undefined'
            }
          },
          sso: {
            token: 'myToken',
            expiration: 1234
          }
        }
      }
      const authData = {
        resultCode: 0
      }
      const processedData = {
        title: true
      }

      sinon.stub(plugin, 'getParams').returns({ eISBN: true, token: 'myToken' })
      sinon.stub(plugin, 'fetchAuth').callsArgWith(3, err, authData)
      sinon.stub(plugin, 'handleAuthSuccess').callsArgWith(3, processedData)
      sinon.stub(plugin, 'shouldRefresh').returns(true)

      plugin.clearSession = sinon.spy()
      plugin.sanitizeUnauthorizedEntitlements = sinon.spy()
      plugin.handleAuthError = sinon.spy()
      plugin.mapToSession = sinon.spy()
      plugin.setSessionValue = sinon.spy()
      plugin.updateAndSaveSession = sinon.spy()
      plugin.getExpiration = sinon.spy()

      plugin.manageSession(req, {}, function() {}, {})

      expect(req.startHandlerTimer.callCount).to.be.eql(1)
      expect(plugin.clearSession.callCount).to.be.eql(1)
      expect(plugin.sanitizeUnauthorizedEntitlements.callCount).to.be.eql(1)
      expect(plugin.handleAuthError.callCount).to.be.eql(0)
      expect(plugin.mapToSession.callCount).to.be.eql(1)
      expect(plugin.setSessionValue.callCount).to.be.eql(3)
      expect(plugin.updateAndSaveSession.callCount).to.be.eql(1)
      expect(req.endHandlerTimer.callCount).to.be.eql(1)
      expect(plugin.getExpiration.callCount).to.be.eql(0)
    })
    
    it('should pass through if authenticated but no token given', () => {
      const plugin = new Plugin({})
      const next = sinon.spy()
      const req = {
        header: () => { return 'localhost' }
      }

      sinon.stub(plugin, 'getParams').returns({})
      sinon.stub(plugin, 'shouldRefresh').returns(false)

      plugin.clearSession = sinon.spy()
      plugin.resumeSession = sinon.spy()

      plugin.manageSession(req, {}, next)

      expect(plugin.resumeSession.callCount).to.be.eql(1)
      expect(plugin.clearSession.callCount).to.be.eql(0)
    })
  })

  describe('resumeSession', () => {

    it('should mapHeaders and call next if an entitlement is mapped', () => {
      const plugin = new Plugin({})
      const next = sinon.spy()
      const req = {
        header: function() { return 'localhost:8080' },
        session: {
          mappings: {
            'localhost:8080': {
              currentEntitlement: 'cgi:123'
            }
          },
          olr: {
            'cgi:123': {
              cgi: 'myCgi'
            }
          }
        }
      }

      plugin.mapToHeaders = sinon.spy()

      plugin.resumeSession(req, {}, next, {})

      expect(plugin.mapToHeaders.callCount).to.be.eql(1)
      expect(next.callCount).to.be.eql(1)
    })

    it('should mapFallbackToHeaders and call next if entitlement has no values stored', () => {
      const plugin = new Plugin({})
      const next = sinon.spy()
      const req = {
        header: function() { return 'localhost:8080' },
        session: {
          mappings: {
            'localhost:8080': {
              currentEntitlement: 'cgi:123'
            }
          },
          olr: {
            'cgi:123': {}
          }
        }
      }

      plugin.mapFallbackToHeaders = sinon.spy()

      plugin.resumeSession(req, {}, next, {})

      expect(plugin.mapFallbackToHeaders.callCount).to.be.eql(1)
      expect(next.callCount).to.be.eql(1)
    })

    it('should just call next if no entitlement is mapped', () => {
      const plugin = new Plugin({})
      const next = sinon.spy()
      const req = {
        header: function() { return 'localhost:8080' },
        session: {
          mappings: {
            'localhost:8080': {
              currentEntitlement: ''
            }
          }
        }
      }

      plugin.mapToHeaders = sinon.spy()

      plugin.resumeSession(req, {}, next, {})

      expect(plugin.mapToHeaders.callCount).to.be.eql(0)
      expect(next.callCount).to.be.eql(1)
    })
  })

  describe('sanitizeUnauthorizedEntitlements', () => {

    it('should clear entitlements not belonging to the current user due to contaminated cookie', () => {
      const plugin = new Plugin({})
      const req = {
        session: {
          sso: {
            guid: '123abc'
          },
          olr: {
            ent1: {
              guid: '123abc'
            },
            ent2: {
              guid: 'xyz987'
            }
          },
          params: {
            ent1: {
              courseKey: 'ent1'
            },
            ent2: {
              courseKey: 'ent2'
            }
          }
        }
      }

      plugin.sanitizeUnauthorizedEntitlements(req)

      expect(req.session.olr.ent1.guid).to.eql('123abc')
      expect(req.session.params.ent1.courseKey).to.eql('ent1')
      expect(req.session.olr.ent2).to.eql(undefined)
      expect(req.session.params.ent2).to.eql(undefined)
    })

    it('should handle an empty olr object', () => {
      const plugin = new Plugin({})
      const req = {
        session: {

        }
      }

      plugin.sanitizeUnauthorizedEntitlements(req)

      expect(req.session.olr).to.be.eql(undefined)
    })

    it('should handle an empty session', () => {
      const plugin = new Plugin({})
      const req = {}

      plugin.sanitizeUnauthorizedEntitlements(req)

      expect(req.session).to.eql(undefined)
    })
  })

  describe('notAuthenticated', () => {

    it('should clear entitlements then hand off notAuthenticated to super', () => {
      const plugin = new Plugin({})
      const req = {
        preserveSession: function(callback) { callback() }
      }
      plugin.handleAuthMode = sinon.spy()
      plugin.setSessionValue = sinon.spy()

      plugin.notAuthenticated(req, {}, function() {}, {}, {})

      expect(plugin.setSessionValue.calledOnce).to.eql(true)
      expect(plugin.handleAuthMode.calledOnce).to.eql(true)
    })
  })

  describe('updateAndSaveSession', () => {

    it('should set current entitlement', () => {
      const plugin = new Plugin({})
      const req = {
        preserveSession: sinon.spy(),
        header: function() { return 'localhost:8080' }
      }
      const reqSession = {
        mappings: {
          'localhost:8080': {
            currentEntitlement: 'cgi:123'
          }
        }
      }
      const next = sinon.spy()

      plugin.updateAndSaveSession(req, next, { namespace: 'cgi:123' })

      expect(req.session).to.be.eql(reqSession)
    })
  })

  describe('clearSession', () => {

    it('should wipe session data and headers with namespace', () => {
      const plugin = new Plugin({})
      const opts = {
        namespace: 'my.namespace'
      }
      const req = {
        session: {
          headers: {
            'cengage-sso-clearMe': true
          },
          olr: {
            'my.namespace': {
              clearMe: true
            }
          }
        },
        header: () => { return 'localhost' }
      }

      plugin.init()
      plugin.clearSession(req, opts)

      expect(req.session.olr['my.namespace'].clearMe).to.be.eql(undefined)
      expect(req.session.olr['my.namespace']).to.be.eql({})
    })
  })
})
